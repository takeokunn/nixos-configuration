#+TITLE: Configurations for GNU Emacs
#+AUTHOR: takeokunn
#+EMAIL: bararararatty@gmail.com
#+STARTUP: content
#+STARTUP: fold
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
* はじめに
** 基本情報
- repo: [[http://github.com/takeokunn/.emacs.d][takeokunn/.emacs.d]]
- twitter: [[https://twitter.com/takeokunn][たけてぃ@takeokunn]]
- blog: [[https://takeokunn.org][https://takeokunn.org]]
** See also
- [[./early-init][early-init.org]]
- [[./yasnippets][yasnippets.org]]
- [[./elfeed][elfeed.org]]
* Header
#+begin_src emacs-lisp :tangle yes
  ;; init.el --- My init.el -*- lexical-binding: t -*-
  ;; Configurations for Emacs
  ;;                                         Takeo Obara  <bararararatty@gmail.com>
#+end_src
* Macro Utilities
** when-darwin
#+begin_src emacs-lisp :tangle yes
  (defmacro when-darwin (&rest body)
    (when (string= system-type "darwin")
      `(progn ,@body)))
#+end_src
** when-darwin-not-window-system
#+begin_src emacs-lisp :tangle yes
  (defmacro when-darwin-not-window-system (&rest body)
    (when (and (string= system-type "darwin")
               window-system)
      `(progn ,@body)))
#+end_src
* Boot
** user
#+begin_src emacs-lisp :tangle yes
  (setq user-full-name "takeokunn")
  (setq user-mail-address "bararararatty@gmail.com")
#+end_src
** profile
#+begin_src emacs-lisp :tangle yes
  (defconst my/enable-profile nil
    "If true, enable profile")

  (when my/enable-profile
    (require 'profiler)
    (profiler-start 'cpu))
#+end_src
** Magic File Name を一時的に無効にする
#+begin_src emacs-lisp :tangle yes
  (defconst my/saved-file-name-handler-alist file-name-handler-alist)

  (setq file-name-handler-alist nil)
#+end_src
** 起動時間計測
#+begin_src emacs-lisp :tangle yes
  (defconst my/before-load-init-time (current-time))

  ;;;###autoload
  (defun my/load-init-time ()
    "Loading time of user init files including time for `after-init-hook'."
    (let ((time1 (float-time
                  (time-subtract after-init-time my/before-load-init-time)))
          (time2 (float-time
                  (time-subtract (current-time) my/before-load-init-time))))
      (message (concat "Loading init files: %.0f [msec], "
                       "of which %.f [msec] for `after-init-hook'.")
               (* 1000 time1) (* 1000 (- time2 time1)))))
  (add-hook 'after-init-hook #'my/load-init-time t)

  (defvar my/tick-previous-time my/before-load-init-time)

  (defun my/emacs-init-time ()
    "Emacs booting time in msec."
    (interactive)
    (message "Emacs booting time: %.0f [msec] = `emacs-init-time'."
             (* 1000
                (float-time (time-subtract
                             after-init-time
                             before-init-time)))))

  (add-hook 'after-init-hook #'my/emacs-init-time)
#+end_src
** autoload-if-found
#+begin_src emacs-lisp :tangle yes
  (defun autoload-if-found (functions file &optional docstring interactive type)
    "Set autoload iff FILE has found."
    (when (locate-library file)
      (dolist (f functions)
        (autoload f file docstring interactive type))))
#+end_src
* Basic
** 末尾のスペースを可視化する
#+begin_src emacs-lisp :tangle yes
  (defun my/disable-show-trailing-whitespace ()
    (setq show-trailing-whitespace nil))

  (with-eval-after-load 'comint
    (add-hook 'comint-mode-hook #'my/disable-show-trailing-whitespace))

  (with-eval-after-load 'esh-mode
    (add-hook 'eshell-mode-hook #'my/disable-show-trailing-whitespace))

  (with-eval-after-load 'minibuffer
    (add-hook 'minibuffer-inactive-mode-hook #'my/disable-show-trailing-whitespace))

  (with-eval-after-load 'prog-mode
    (add-hook 'prog-mode-hook #'my/disable-show-trailing-whitespace))

  (with-eval-after-load 'text-mode
    (add-hook 'text-mode-hook #'my/disable-show-trailing-whitespace))
#+END_SRC
** 行番号を表示する
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-display-line-numbers-mode) "display-line-numbers" nil t)

  ;; (add-hook 'emacs-startup-hook #'global-display-line-numbers-mode)

  (with-eval-after-load 'display-line-numbers
    (setopt display-line-numbers-grow-only t))
#+END_SRC
** C-kで行削除
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'simple
    (setopt kill-whole-line t))
#+END_SRC
** カッコの中をハイライトする
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(show-paren-local-mode) "display-line-numbers" nil t)

  (with-eval-after-load 'prog-mode
    (add-hook 'prog-mode-hook #'show-paren-local-mode))

  (with-eval-after-load 'paren
    (setopt show-paren-style 'mixed))
#+END_SRC
** カッコが自動的に作られるようにする
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'electric-pair-mode)
#+END_SRC
** TODO coding system
#+begin_src emacs-lisp :tangle yes
  ;; ;; coding system
  ;; (add-hook 'emacs-startup-hook
  ;;           #'(lambda ()
  ;;               (set-default-coding-systems 'utf-8-unix)
  ;;               (prefer-coding-system 'utf-8-unix)
  ;;               (set-selection-coding-system 'utf-8-unix)))

  ;; ;; prefer-coding-system take effect equally to follows
  ;; (add-hook 'emacs-startup-hook
  ;;           #'(lambda ()
  ;;               (setq locale-coding-system 'utf-8-unix)
  ;;               (set-buffer-file-coding-system 'utf-8-unix)
  ;;               (set-file-name-coding-system 'utf-8-unix)
  ;;               (set-terminal-coding-system 'utf-8-unix)
  ;;               (set-keyboard-coding-system 'utf-8-unix)))
#+end_src
** global-auto-revert-mode
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'global-auto-revert-mode)
#+end_src
** yes/no to y/n
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook
            #'(lambda ()
                (fset 'yes-or-no-p 'y-or-n-p)))
#+end_src
** minibuffer
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'minibuffer
    (define-key minibuffer-mode-map (kbd "C-j") #'exit-minibuffer)
    (define-key minibuffer-mode-map (kbd "M-RET") #'exit-minibuffer))

  (setq enable-recursive-minibuffers t)
#+end_src
** savehistを有効にする
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'savehist-mode)
#+end_src
** [mac] clipboardに入るようにする
#+begin_src emacs-lisp :tangle yes
  (defun my/copy-from-osx ()
    (shell-command-to-string "pbpaste"))

  (defun my/paste-to-osx (text)
    (let ((process-connection-type nil))
      (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
        (process-send-string proc text)
        (process-send-eof proc))))

  (when-darwin-not-window-system
   (setq interprogram-cut-function #'my/paste-to-osx)
   (setq interprogram-paste-function #'my/copy-from-osx))
#+end_src
** native comp
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'comp-run
    ;; config
    (setopt native-comp-async-jobs-number 8)
    (setopt native-comp-speed 3)
    (setopt native-comp-always-compile t))

  (with-eval-after-load 'warnings
    ;; config
    (setopt warning-suppress-types '((comp))))
#+end_src
** 同一bufferの名前を変える
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'uniquify
    (setopt uniquify-buffer-name-style 'post-forward-angle-brackets))
#+end_src
** killできないようにする
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook
            #'(lambda ()
                (with-current-buffer "*scratch*"
                  (emacs-lock-mode 'kill))
                (with-current-buffer "*Messages*"
                  (emacs-lock-mode 'kill))))
#+end_src
** 日時表示
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'time
    (setopt display-time-24hr-format t))
#+end_src
** warning level
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'warnings
    (setopt warning-minimum-level :error))
#+end_src
** キーコマンド入力中に入力過程をミニバッファに反映する
#+begin_src emacs-lisp :tangle yes
  (setq echo-keystrokes 0.1)
#+end_src
** save-place-mode
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'save-place-mode)
#+end_src
** enable-local-variables
#+begin_src emacs-lisp :tangle yes
  (setq enable-local-variables :all)
#+end_src
** password
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'password-cache
    ;; config
    (setq password-cache t)
    (setq password-cache-expiry 3600))
#+end_src
** 検索で大文字小文字を区別しない
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'minibuffer
    (setopt read-file-name-completion-ignore-case t))

  (setq completion-ignore-case t)
  (setq read-buffer-completion-ignore-case t)
#+end_src
** time locale
#+begin_src emacs-lisp :tangle yes
  (setq system-time-locale "C")
#+END_SRC
** kill-ringのサイズを変更
#+begin_src emacs-lisp :tangle yes
  (setopt kill-ring-max 100000)

  (custom-set-variables '(savehist-additional-variables '(kill-ring)))
#+end_src
** 折り返ししない
#+begin_src emacs-lisp :tangle yes
  (setq truncate-lines t)
  (setq truncate-partial-width-windows t)
#+end_src
* Global Keybind
** basic
#+begin_src emacs-lisp :tangle yes
  (keymap-global-set "M-¥" #'(lambda () (interactive) (insert "\\")))
  (keymap-global-set "C-a" #'back-to-indentation)
  (keymap-global-set "C-z" nil)
  (keymap-global-set "C-;" #'comment-dwim)
  (keymap-global-set "C-M-/" #'undo-redo)
  (keymap-global-set "C-c i" #'find-function)
  (keymap-global-set "C-c C-o" #'org-open-at-point)
  (keymap-global-set "C-x C-o" #'other-window)

  (keymap-global-unset "C-x C-k")

  (keymap-global-set "M-d" #'my/delete-forward-block)

  (when window-system
    (keymap-global-unset "C-x C-c"))
#+END_SRC
* Language
** ansible
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ansible-mode) "ansible" nil t)
#+end_src
** apache-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(apache-mode) "apache-mode" nil t)

  (add-to-list 'auto-mode-alist '("/\\.htaccess\\'" . apache-mode))
  (add-to-list 'auto-mode-alist '("/\\(?:access\\|httpd\\|srm\\)\\.conf\\'" . apache-mode))
  (add-to-list 'auto-mode-alist '("/apache2/.+\\.conf\\'" . apache-mode))
  (add-to-list 'auto-mode-alist '("/httpd/conf/.+\\.conf\\'" . apache-mode))
  (add-to-list 'auto-mode-alist '("/apache2/sites-\\(?:available\\|enabled\\)/" . apache-mode))

  (with-eval-after-load 'apache-mode
    ;; hook
    (add-hook 'apache-mode-hook #'view-mode))
#+end_src
** bazel-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(bazel-mode) "bazel" nil t)
#+end_src
** bison-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(bison-mode flex-mode jison-mode) "bison-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.y\\'" . bison-mode))
  (add-to-list 'auto-mode-alist '("\\.l\\'" . flex-mode))
  (add-to-list 'auto-mode-alist '("\\.jison\\'" . jison-mode))
#+end_src
** cask-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(cask-mode) "cask-mode" nil t)

  (add-to-list 'auto-mode-alist '("/Cask\\'" . cask-mode))
#+end_src
** cfn-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(cfn-mode) "cfn-mode" nil t)

  (add-to-list 'magic-mode-alist '("\\(---\n\\)?AWSTemplateFormatVersion:" . cfn-mode))

  (with-eval-after-load 'cfn-mode
    ;; hooks
    (add-hook 'cfn-mode-hook #'flycheck-mode)
    (add-hook 'cfn-mode-hook #'view-mode))
#+end_src
** clojure-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(clojure-mode clojurescript-mode) "clojure-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.clj$" . clojure-mode))
  (add-to-list 'auto-mode-alist '("\\.cljs$" . clojurescript-mode))

  (with-eval-after-load 'clojure-mode
    ;; config
    (setopt clojure-toplevel-inside-comment-form t))
#+END_SRC
** cmake-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(cmake-mode) "cmake-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.cmake$" . cmake-mode))
#+END_SRC
** coffee-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(coffee-mode) "coffee-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.coffee$" . coffee-mode))
#+END_SRC
** conf-mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.cnf$" . conf-mode))
  (add-to-list 'auto-mode-alist '("yabairc$" . conf-mode))
  (add-to-list 'auto-mode-alist '("skhdrc$" . conf-mode))

  (with-eval-after-load 'conf-mode
    ;; hook
    (add-hook 'conf-mode-hook #'view-mode))
#+end_src
** crontab-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(crontab-mode) "crontab-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.?cron\\(tab\\)?\\'" . crontab-mode))

  (with-eval-after-load 'crontab-mode
    ;; hook
    (add-hook 'crontab-mode-hook #'view-mode))
#+end_src
** csharp-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(csharp-mode) "csharp-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.cs$" . csharp-mode))
#+END_SRC
** csv-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(csv-mode) "csv-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.csv$" . csv-mode))

  (with-eval-after-load 'csv-mode
    ;; hook
    (add-hook 'csv-mode-hook #'view-mode))
#+END_SRC
** cuda-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(cuda-mode) "cuda-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.cu$" . cuda-mode))
#+end_src
** crystal-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(crystal-mode) "crystal-mode" nil t)

  (add-to-list 'auto-mode-alist '("Projectfile$" . crystal-mode))
  (add-to-list 'auto-mode-alist
               (cons (purecopy (concat "\\(?:\\."
                                       "cr"
                                       "\\)\\'")) 'crystal-mode))
#+end_src
** dart-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dart-mode) "dart-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.dart$" . dart-mode))
#+end_src
** dhall-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dhall-mode) "dhall-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.dhall$" . dhall-mode))
#+end_src
** direnv-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(direnv-envrc-mode direnv--enable direnv--disable) "direnv" nil t)

  (add-to-list 'auto-mode-alist '("\\.envrc$" . direnv-envrc-mode))

  (with-eval-after-load 'direnv
    ;; config
    (setopt direnv-always-show-summary nil)
    (setopt direnv-show-paths-in-summary nil)
    (setopt direnv-use-faces-in-summary nil)

    ;; hook
    (add-hook 'direnv-mode-hook #'view-mode))
#+end_src
** docker-compose-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(docker-compose-mode) "docker-compose-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\docker-compose*" . docker-compose-mode))

  (with-eval-after-load 'docker-compose-mode
    ;; hook
    (add-hook 'docker-compose-mode-hook #'view-mode))
#+end_src
** dockerfile-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dockerfile-mode) "dockerfile-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\Dockerfile$" . dockerfile-mode))
  (add-to-list 'auto-mode-alist '("\\Dockerfile_Ecs$" . dockerfile-mode))
  (add-to-list 'auto-mode-alist '("\\Dockerfile_EcsDeploy" . dockerfile-mode))

  (with-eval-after-load 'dockerfile-mode
    ;; hooks
    (add-hook 'dockerfile-mode-hook #'flycheck-mode))
#+END_SRC
** dotenv-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dotenv-mode) "dotenv-mode" nil t)

  (add-to-list 'auto-mode-alist '(".env$" . dotenv-mode))

  (with-eval-after-load 'dotenv-mode
    (add-hook 'dotenv-mode-hook #'view-mode))
#+end_src
** elixir-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elixir-mode) "elixir-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.elixir$" . elixir-mode))
  (add-to-list 'auto-mode-alist '("\\.ex$" . elixir-mode))
  (add-to-list 'auto-mode-alist '("\\.exs$" . elixir-mode))
  (add-to-list 'auto-mode-alist '("mix\\.lock" . elixir-mode))
#+end_src
** elm-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elm-mode) "elm-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.elm$" . elm-mode))
#+end_src
** emacs-lisp-mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("Keg" . emacs-lisp-mode))
#+end_src
** fish-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(fish-mode) "fish-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.fish$" . fish-mode))

  (with-eval-after-load 'fish-mode
    ;; config
    (setopt fish-enable-auto-indent t))
#+END_SRC
** forth-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(forth-mode) "forth-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.f$" . forth-mode))
  (add-to-list 'auto-mode-alist '("\\.fs$" . forth-mode))
  (add-to-list 'auto-mode-alist '("\\.fth$" . forth-mode))
  (add-to-list 'auto-mode-alist '("\\.forth$" . forth-mode))
  (add-to-list 'auto-mode-alist '("\\.4th$" . forth-mode))
#+end_src
** fortran
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(f90-mode) "f90" nil t)

  (add-to-list 'auto-mode-alist '("\\.f\\(y90\\|y?pp\\)\\'" . f90-mode))
#+end_src
** fsharp-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(fsharp-mode) "fsharp-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.fs[iylx]?$" . fsharp-mode))
#+end_src
** git-modes
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(gitignore-mode gitconfig-mode gitattributes-mode) "git-modes" nil t)

  ;; gitignore-mode
  (add-to-list 'auto-mode-alist '("\\.dockerignore$" . gitignore-mode))
  (add-to-list 'auto-mode-alist '("\\.gitignore$" . gitignore-mode))
  (add-to-list 'auto-mode-alist '("\\.prettierignore$" . gitignore-mode))
  (add-to-list 'auto-mode-alist '("/git/ignore\\'" . gitignore-mode))
  (add-to-list 'auto-mode-alist '("/git/ignore\\'" . gitignore-mode))
  (add-to-list 'auto-mode-alist '("CODEOWNERS" . gitignore-mode))

  (with-eval-after-load 'gitignore-mode
    ;; hook
    (add-hook 'gitignore-mode-hook #'view-mode))

  ;; gitconfig-mode
  (add-to-list 'auto-mode-alist '("\\.git-pr-release$" . gitconfig-mode))
  (add-to-list 'auto-mode-alist '("\\.editorconfig$" . gitconfig-mode))
  (add-to-list 'auto-mode-alist '("\\.gitconfig$" . gitconfig-mode))
  (add-to-list 'auto-mode-alist '("/\\.git/config\\'" . gitconfig-mode))
  (add-to-list 'auto-mode-alist '("/modules/.*/config\\'" . gitconfig-mode))
  (add-to-list 'auto-mode-alist '("/git/config\\'" . gitconfig-mode))
  (add-to-list 'auto-mode-alist '("/\\.gitmodules\\'" . gitconfig-mode))
  (add-to-list 'auto-mode-alist '("/etc/gitconfig\\'" . gitconfig-mode))

  (with-eval-after-load 'gitconfig-mode
    ;; hook
    (add-hook 'gitconfig-mode-hook #'view-mode))

  ;; gitattributes
  (add-to-list 'auto-mode-alist '("/\\.gitattributes\\'" . gitattributes-mode))
  (add-to-list 'auto-mode-alist '("\.gitattributes$" . gitattributes-mode))
  (add-to-list 'auto-mode-alist '("/info/attributes\\'" . gitattributes-mode))
  (add-to-list 'auto-mode-alist '("/git/attributes\\'" . gitattributes-mode))

  (with-eval-after-load 'gitattributes-mode
    ;; hook
    (add-hook 'gitattributes-mode-hook #'view-mode))
#+end_src
** glsl-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(glsl-mode) "glsl-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.vsh$" . glsl-mode))
  (add-to-list 'auto-mode-alist '("\\.fsh$" . glsl-mode))
#+END_SRC
** go-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(go-mode gofmt) "go-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.go$" . go-mode))
  (add-to-list 'auto-mode-alist '("^go.mod$" . go-mode))

  (with-eval-after-load 'go-mode
    ;; config
    (setopt gofmt-command "goimports"))
#+END_SRC
** gradle-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(gradle-mode) "gradle-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.gradle$" . gradle-mode))
#+END_SRC
** graphql-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(graphql-mode) "graphql-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.graphql\\'" . graphql-mode))

  (with-eval-after-load 'graphql-mode
    ;; config
    (setopt graphql-indent-level 4))
#+end_src
** graphviz-dot-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(graphviz-dot-mode) "graphviz-dot-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.dot\\'" . graphviz-dot-mode))
  (add-to-list 'auto-mode-alist '("\\.gv\\'" . graphviz-dot-mode))

  (with-eval-after-load 'graphviz-dot-mode
    ;; config
    (setopt graphviz-dot-auto-indent-on-semi nil)
    (setopt graphviz-dot-indent-width 2))
#+end_src
** groovy-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(groovy-mode) "groovy-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.g\\(?:ant\\|roovy\\|radle\\)\\'" . groovy-mode))
  (add-to-list 'auto-mode-alist '("/Jenkinsfile\\'" . groovy-mode))
  (add-to-list 'interpreter-mode-alist '("groovy" . groovy-mode))
#+end_src
** hack-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(hack-mode) "hack-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.hack$" . hack-mode))
  (add-to-list 'auto-mode-alist '("\\.hck$" . hack-mode))
  (add-to-list 'auto-mode-alist '("\\.hhi$" . hack-mode))
#+end_src
** haskell-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(haskell-mode) "haskell-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.cable$" . haskell-mode))
#+END_SRC
** hcl-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(hcl-mode) "hcl-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.hcl$" . hcl-mode))
#+end_src
** hy-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(hy-mode) "hy-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.hy$" . hy-mode))
#+end_src
** ini-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ini-mode) "ini-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.ini$" . ini-mode))
#+end_src
** jade-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(jade-mode) "jade-mode" nil t)
  (autoload-if-found '(stylus-mode) "stylus-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.jade$" . jade-mode))
  (add-to-list 'auto-mode-alist '("\\.styl\\'" . stylus-mode))
#+end_src
** java-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(java-mode) "java-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.java$" . java-mode))
#+end_src
** js2-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(js2-mode) "js2-mode" nil t)

  ;; js2-mode
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
  (add-to-list 'auto-mode-alist '("\\.mjs$" . js2-mode))

  (with-eval-after-load 'js2-mode
    ;; config
    (setopt js2-strict-missing-semi-warning nil)
    (setopt js2-missing-semi-one-line-override nil))
#+END_SRC
** json-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(json-mode) "json-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.json$" . json-mode))
  (add-to-list 'auto-mode-alist '("\\.textlintrc$" . json-mode))
  (add-to-list 'auto-mode-alist '("\\.prettierrc$" . json-mode))
  (add-to-list 'auto-mode-alist '("\\.markuplintrc$" . json-mode))

  (with-eval-after-load 'json-mode
    ;; hooks
    (add-hook 'json-mode-hook #'flycheck-mode))
#+END_SRC
** jsonnet-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(jsonnet-mode
                       jsonnet-eval-buffer
                       jsonnet-jump
                       jsonnet-reformat-buffer) "jsonnet-mode" nil t)

  (add-to-list 'auto-mode-alist (cons "\\.jsonnet\\'" 'jsonnet-mode))
  (add-to-list 'auto-mode-alist (cons "\\.libsonnet\\'" 'jsonnet-mode))

  (with-eval-after-load 'jsonnet-mode
    ;; config
    (setopt jsonnet-indent-level 4)

    ;; keybind
    (define-key jsonnet-mode-map (kbd "C-c C-c") #'jsonnet-eval-buffer)
    (define-key jsonnet-mode-map (kbd "C-c C-f") #'jsonnet-jump)
    (define-key jsonnet-mode-map (kbd "C-c C-r") #'jsonnet-reformat-buffer))
#+end_src
** kotlin-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(kotlin-mode) "kotlin-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.kts?\\'" . kotlin-mode))
#+end_src
** lisp-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lisp-mode) "lisp-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.lemrc$" . lisp-mode))
  (add-to-list 'auto-mode-alist '("\\.sbclrc$" . lisp-mode))
#+END_SRC
** lua-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lua-mode) "lua-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
#+end_src
** markdown-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(markdown-mode) "markdown-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.markdown$" . markdown-mode))

  (with-eval-after-load 'markdown-mode
    ;; config
    (setopt markdown-code-lang-modes (append '(("diff" . diff-mode)
                                               ("hs" . haskell-mode)
                                               ("html" . web-mode)
                                               ("ini" . conf-mode)
                                               ("js" . web-mode)
                                               ("jsx" . web-mode)
                                               ("md" . markdown-mode)
                                               ("pl6" . raku-mode)
                                               ("py" . python-mode)
                                               ("rb" . ruby-mode)
                                               ("rs" . rustic-mode)
                                               ("sqlite3" . sql-mode)
                                               ("ts" . typescript-mode)
                                               ("typescript" . typescript-mode)
                                               ("tsx" . web-mode)
                                               ("yaml". yaml-mode)
                                               ("zsh" . sh-mode)
                                               ("php" . php-mode))
                                             markdown-code-lang-modes))

    ;; hook
    (add-hook 'markdown-mode #'orgtbl-mode)
    (add-hook 'markdown-mode #'view-mode))
#+END_SRC
** mermaid-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(mermaid-mode) "mermaid-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.mmd\\'" . mermaid-mode))
#+end_src
** makefile-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(makefile-mode) "makefile-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.mk$" . makefile-mode))
  (add-to-list 'auto-mode-alist '("Makefile" . makefile-mode))

  (with-eval-after-load 'makefile-mode
    ;; config
    (setopt makefile-electric-keys t)

    ;; hook
    (add-hook 'makefile-mode-hook #'flycheck-mode))
#+end_src
** nasm-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nasm-mode) "nasm-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.s$" . nasm-mode))
#+end_src
** neon-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(neon-mode) "neon-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.neon$" . neon-mode))

  (with-eval-after-load 'neon-mode
    (add-hook 'neon-mode-hook #'view-mode))
#+end_src
** nim-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nim-mode) "nim-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.nim\\'" . nim-mode))
#+end_src
** ninja-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ninja-mode) "ninja-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.ninja$" . ninja-mode))
#+end_src
** nix-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nix-mode) "nix-mode" nil t)
  (autoload-if-found '(nix-drv-mode) "nix-drv-mode" nil t)
  (autoload-if-found '(nix-shell-unpack nix-shell-configure nix-shell-build) "nix-shell" nil t)
  (autoload-if-found '(nix-repl) "nix-repl" nil t)
  (autoload-if-found '(nix-format-buffer) "nix-format" nil t)

  (add-to-list 'auto-mode-alist '("\\.nix$" . nix-mode))
  (add-to-list 'auto-mode-alist '("\\.drv$" . nix-drv-mode))

  (defun my/nix-fmt ()
    (interactive)
    (let ((default-directory (locate-dominating-file default-directory ".git")))
      (shell-command-to-string "nix fmt")))
#+end_src
** nginx-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nginx-mode) "nginx-mode" nil t)

  (add-to-list 'auto-mode-alist '("nginx\\.conf\\'" . nginx-mode))
  (add-to-list 'auto-mode-alist '("/nginx/.+\\.conf\\'" . nginx-mode))
  (add-to-list 'auto-mode-alist '("/nginx/sites-\\(?:available\\|enabled\\)/" . nginx-mode))

  (with-eval-after-load 'nginx-mode
    ;; config
    (setopt nginx-indent-tabs-mode t))
#+END_SRC
** nov-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nov-mode) "nov" nil t)

  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))

  (with-eval-after-load 'nov-mode
    ;; hooks
    (add-hook 'nov-mode-hook #'view-mode))
#+end_src
** pcap-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(pcap-mode) "pcap" nil t)

  (add-to-list 'auto-mode-alist '("\\.pcap$" . pcap-mode))
#+end_src
** phel-mode
#+begin_src emacs-lisp :tangle yes
  (define-derived-mode phel-mode clojure-mode "Phel"
    "Major mode for editing Phel language source files."
    (setq-local comment-start "#")
    ;; We disable lockfiles so that ILT evaluation works.
    ;; The lockfiles seem to modify the buffer-file-name somehow, when the buffer changes
    ;; And that is detected by the currently running Phel process.
    ;; That interferes with evaluation, as the running Phel process starts behaving badly because of that.
    (setq-local create-lockfiles nil)
    )

  (add-to-list 'auto-mode-alist '("\\.phel$" . phel-mode))
#+end_src
** php-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(php-mode php-current-class php-current-namespace) "php-mode" nil t)
  (autoload-if-found '(php-format-this-buffer-file) "php-format" nil t)

  (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))

  (with-eval-after-load 'php-mode
    ;; keybind
    (define-key php-mode-map (kbd "C-c C--") #'php-current-class)
    (define-key php-mode-map (kbd "C-c C-=") #'php-current-namespace)
    (define-key php-mode-map (kbd "C-.") nil)

    ;; config
    (setopt php-mode-coding-style 'psr2)

    ;; phpstan
    (define-derived-mode phpstan-mode php-mode "phpstan"))
#+END_SRC
** phpt-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(phpt-mode) "phpt-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.phpt$" . phpt-mode))
#+end_src
** plantuml-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(plantuml-mode) "plantuml-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.pu$" . plantuml-mode))
#+END_SRC
** po-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(po-mode) "po-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.po$" . po-mode))
#+END_SRC
** prolog
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(prolog-mode) "prolog-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.pl$" . prolog-mode))
#+end_src
** protobuf-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(protobuf-mode) "protobuf-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.proto\\'" . protobuf-mode))
#+end_src
** pug-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(pug-mode) "pug-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.pug$" . pug-mode))
#+end_src
** prisma-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(prisma-mode) "prisma-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.prisma" . prisma-mode))
#+end_src
** processing-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(processing-mode) "processing-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.pde$" . processing-mode))

  (with-eval-after-load 'processing-mode
    ;; config
    (setopt processing-output-dir "/tmp"))
#+END_SRC
** python-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(python-mode) "python-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.py$" . python-mode))
#+END_SRC
** qt-pro-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(qt-pro-mode) "qt-pro-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.pr[io]$" . qt-pro-mode))
#+end_src
** racket-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(racket-mode) "racket-mode" nil t)
#+end_src
** robots-txt-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(robots-txt-mode) "robots-txt-mode" nil t)

  (add-to-list 'auto-mode-alist '("/robots\\.txt\\'" . robots-txt-mode))
#+end_src
** ruby-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ruby-mode) "ruby-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.irbrc$" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Capfile" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Gemfile" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Schemafile" . ruby-mode))
  (add-to-list 'auto-mode-alist '(".pryrc" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Fastfile" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Matchfile" . ruby-mode))
  (add-to-list 'auto-mode-alist '("Procfile" . ruby-mode))
  (add-to-list 'auto-mode-alist '(".git-pr-template" . ruby-mode))
  (add-to-list 'auto-mode-alist '(".gemrc" . ruby-mode))
  (add-to-list 'auto-mode-alist '("\\.Brewfile" . ruby-mode))

  (with-eval-after-load 'ruby-mode
    ;; config
    (setopt ruby-insert-encoding-magic-comment nil))
#+END_SRC
** rust-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(rust-mode) "rust-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.rs$" . rust-mode))

  (with-eval-after-load 'rust-rustfmt
    ;; config
    (setopt rust-format-on-save t))
#+END_SRC
** scala-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(scala-mode) "scala-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.scala$" . scala-mode))
#+END_SRC
** scheme-mode
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.scheme$" . scheme-mode))
  (add-to-list 'auto-mode-alist '(".guix-channel" . scheme-mode))

  (with-eval-after-load 'scheme
    ;; config
    (setopt scheme-program-name "gosh -i"))
#+end_src
** scad-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(scad-mode) "scad-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.scad\\'" . scad-mode))
#+end_src
** scss-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(scss-mode) "scss-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.scss$" . scss-mode))
  (add-to-list 'auto-mode-alist '("\\.sass$" . scss-mode))

  (with-eval-after-load 'scss-mode
    ;; hooks
    (add-hook 'scss-mode-hook #'flycheck-mode))
#+end_src
** shell-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(shell-mode) "shell-mode" nil t)

  (define-derived-mode console-mode shell-mode "console")
#+end_src
** slim-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(slim-mode) "slim-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.slim$" . slim-mode))
#+END_SRC
** solidity-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(solidity-mode) "solidity-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.sol$" . solidity-mode))
#+end_src
** ssh-config-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ssh-config-mode ssh-known-hosts-mode ssh-authorized-keys-mode) "ssh-config-mode" nil t)

  (add-to-list 'auto-mode-alist '("/\\.ssh/config\\(\\.d/.*\\.conf\\)?\\'" . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("/sshd?_config\\(\\.d/.*\\.conf\\)?\\'" . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("/known_hosts\\'" . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("/authorized_keys2?\\'" . ssh-config-mode))

  (with-eval-after-load 'ssh-config-mode
    ;; hooks
    (add-hook 'ssh-config-mode-hook #'view-mode)
    (add-hook 'ssh-known-hosts-mode-hook #'view-mode))
#+END_SRC
** sql-mode
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'sql
    (load-library "sql-indent")

    ;; config
    (setq sql-user "root")
    (setq sql-password "P@ssw0rd")
    (setq sql-server "127.0.0.1")
    (setq sql-port 13306)
    (setq sql-mysql-login-params '(server port user password database))

    ;; hook
    (add-hook 'sql-mode-hook #'flycheck-mode))
#+end_src
** swift-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(swift-mode) "swift-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.swift$" . swift-mode))
#+end_src
** syslog-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(syslog-mode) "syslog-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.log$" . syslog-mode))
#+end_src
** systemd-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(systemd-mode) "systemd" nil t)

  (add-to-list 'auto-mode-alist '("\\.nspawn\\'" . systemd-mode))
  (add-to-list 'auto-mode-alist `(,(rx (+? (any "a-zA-Z0-9-_.@\\")) "."
                                       (or "automount" "busname" "mount" "service" "slice"
                                           "socket" "swap" "target" "timer" "link" "netdev" "network")
                                       string-end)
                                  . systemd-mode))
  (add-to-list 'auto-mode-alist `(,(rx ".#"
                                       (or (and (+? (any "a-zA-Z0-9-_.@\\")) "."
                                                (or "automount" "busname" "mount" "service" "slice"
                                                    "socket" "swap" "target" "timer" "link" "netdev" "network"))
                                           "override.conf")
                                       (= 16 (char hex-digit)) string-end)
                                  . systemd-mode))
  (add-to-list 'auto-mode-alist `(,(rx "/systemd/" (+? anything) ".d/" (+? (not (any ?/))) ".conf" string-end)
                                  . systemd-mode))

  (with-eval-after-load 'systemd
    ;; hooks
    (add-hook 'systemd-mode-hook #'view-mode))
#+end_src
** terraform-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(terraform-mode) "terraform-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.tf$" . terraform-mode))

  (with-eval-after-load 'terraform-mode
    ;; hooks
    (add-hook 'terraform-mode-hook #'flycheck-mode))
#+END_SRC
** text-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(conf-space-mode) "conf-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.tigrc$" . conf-space-mode))
  (add-to-list 'auto-mode-alist '("\\.editrc$" . conf-space-mode))
  (add-to-list 'auto-mode-alist '("\\.inputrc$" . conf-space-mode))
  (add-to-list 'auto-mode-alist '("\\.colorrc$" . conf-space-mode))
  (add-to-list 'auto-mode-alist '("\\.asdfrc$" . conf-space-mode))
  (add-to-list 'auto-mode-alist '("credentials$" . conf-space-mode))

  (with-eval-after-load 'conf-mode
    (add-hook 'conf-space-mode-hook #'view-mode))
#+end_src
** toml-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(toml-mode) "toml-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.toml$" . toml-mode))

  (with-eval-after-load 'toml-mode
    ;; hooks
    (add-hook 'toml-mode-hook #'flycheck-mode)
    (add-hook 'toml-mode-hook #'view-mode))
#+END_SRC
** tmux-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(tmux-mode) "tmux-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.tmux\\.conf$" . tmux-mode))
#+end_src
** typescript-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(typescript-mode) "typescript-mode" nil t)

  ;; for ts/deno
  (add-to-list 'auto-mode-alist '("\\.ts$" . typescript-mode))

  ;; for tsx
  (define-derived-mode typescript-tsx-mode typescript-mode "tsx")
  (add-to-list 'auto-mode-alist '("\\.jsx$" . typescript-tsx-mode))
  (add-to-list 'auto-mode-alist '("\\.tsx$" . typescript-tsx-mode))
#+END_SRC
** typst-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(typst-mode) "typst-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.typ$" . typst-mode))

  (with-eval-after-load 'typst-mode
    (add-hook 'typst-mode-hook #'view-mode))
#+END_SRC
** v-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(v-mode v-menu v-format-buffer) "v-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\(\\.v?v\\|\\.vsh\\)$" . v-mode))

  (with-eval-after-load 'v-mode
    ;; keybind
    (define-key v-mode-map (kbd "M-z") #'v-menu)
    (define-key v-mode-map (kbd "C-c C-f") #'v-format-buffer))
#+end_src
** vue-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(vue-mode) "vue-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.vue$" . vue-mode))

  (with-eval-after-load 'vue-html-mode
    ;; config
    (setopt vue-html-extra-indent 4))
#+END_SRC
** vimrc-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(vimrc-mode) "vimrc-mode" nil t)

  (add-to-list 'auto-mode-alist '("vimrc" . vimrc-mode))
  (add-to-list 'auto-mode-alist '("\\.vim\\(rc\\)?\\'" . vimrc-mode))
#+end_src
** wat-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(wat-mode) "wat-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.wat?\\'" . wat-mode))
#+end_src
** web-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(web-mode) "web-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.gsp$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.svg$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.liquid$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.ejs$" . web-mode))

  (with-eval-after-load 'web-mode
    ;; config
    (setopt web-mode-comment-style 2)
    (setopt web-mode-enable-auto-pairing nil)
    (setopt web-mode-enable-auto-indentation nil))
#+END_SRC
** web-php-blade-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(web-php-blade-mode) "web-php-blade-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.blade\\.php$" . web-php-blade-mode))
#+end_src
** wolfram-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(wolfram-mode run-wolfram) "wolfram-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.m$" . wolfram-mode))
  (add-to-list 'auto-mode-alist '("\\.nb$" . wolfram-mode))
  (add-to-list 'auto-mode-alist '("\\.cbf$" . wolfram-mode))

  (with-eval-after-load 'wolfram-mode
    ;; config
    (setopt wolfram-path "path-to-dir"))
#+end_src
** yaml-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(yaml-mode) "yaml-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.aclpolicy$" . yaml-mode))

  (with-eval-after-load 'yaml-mode
    ;; hooks
    (add-hook 'yaml-mode-hook #'flycheck-mode)
    (add-hook 'yaml-mode-hook #'view-mode))
#+END_SRC
** yarn-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(yarn-mode) "yarn-mode" nil t)

  (add-to-list 'auto-mode-alist '("yarn\\.lock\\'" . yarn-mode))

  (with-eval-after-load 'yarn-mode
    ;; hooks
    (add-hook 'yarn-mode-hook #'view-mode))
#+end_src
** zig-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(zig-mode) "zig-mode" nil t)

  (add-to-list 'auto-mode-alist '("\\.zig$" . zig-mode))
#+end_src
* IME
** ddskk
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(skk-mode) "ddskk-autoloads" nil t)

  (keymap-global-set "C-x C-j" #'skk-mode)

  (defun my/skk-C-j-key (arg)
    (interactive "P")
    (cond
     ((and (null (skk-in-minibuffer-p))
           (null skk-henkan-mode))
      (skk-emulate-original-map arg))
     (t
      (skk-kakutei arg))))

  (with-eval-after-load 'skk
    ;; config
    (setq skk-preload t)
    (setq default-input-method "japanese-skk"))

  (with-eval-after-load 'skk-vars
    ;; use skkserv
    (when-darwin
     (setq skk-server-host "localhost")
     (setq skk-server-portnum 1178))

    ;; guix
    (setq skk-byte-compile-init-file t)
    (setq skk-isearch-mode-enable 'always)
    (setq skk-egg-like-newline t)
    (setq skk-show-annotation nil)
    (setq skk-auto-insert-paren t)

    ;; azik
    (setq skk-use-azik t)
    (setq skk-azik-keyboard-type 'jp106)

    ;; ref: https://github.com/skk-dev/ddskk/blob/master/etc/dot.skk#L752-L768
    (add-to-list 'skk-rom-kana-rule-list '(skk-kakutei-key nil my/skk-C-j-key)))
#+END_SRC
** ddskk-posframe
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ddskk-posframe-mode) "ddskk-posframe" nil t)

  (with-eval-after-load 'skk
    ;; hooks
    (add-hook 'skk-mode-hook #'ddskk-posframe-mode))
#+end_src
* Coding
** Check
*** flymake-proc
#+begin_src emacs-lisp :tangle yes
  (require 'flymake-proc)
#+end_src
*** flycheck
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(flycheck-mode flycheck-define-checker) "flycheck" nil t)
#+end_src
*** flycheck-textlint
#+begin_src emacs-lisp :tangle yes
  (defun my/flycheck-textlint-setup ()
    (interactive)
    (flycheck-define-checker textlint
      "A linter for prose."
      :command ("textlint" "--format" "unix" source-inplace)
      :error-patterns
      ((warning line-start (file-name) ":" line ":" column ": "
                (id (one-or-more (not (any " "))))
                (message (one-or-more not-newline)
                         (zero-or-more "\n" (any " ") (one-or-more not-newline)))
                line-end))
      :modes (org-mode))
    (add-to-list 'flycheck-checkers 'textlint))

  (add-hook 'emacs-startup-hook #'my/flycheck-textlint-setup)
#+end_src
*** flycheck-elsa
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(flycheck-elsa-setup) "flycheck-elsa" nil t)

  (with-eval-after-load 'elisp-mode
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'flycheck-elsa-setup))
#+end_src
*** flycheck-projectile
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(flycheck-projectile-list-errors) "flycheck-projectile" nil t)
#+end_src
*** flycheck-cfn
#+begin_src emacs-lisp
  (autoload-if-found '(flycheck-cfn-setup) "flycheck-cfn" nil t)

  (with-eval-after-load 'cfn-mode
    ;; hooks
    (add-hook 'cfn-mode-hook #'flycheck-cfn-setup))
#+end_src
** Completion
*** corfu
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-corfu-mode) "corfu" nil t)

  (add-hook 'emacs-startup-hook #'global-corfu-mode)

  (with-eval-after-load 'corfu
    ;; config
    (setopt corfu-auto t)
    (setopt corfu-auto-delay 0.2)
    (setopt corfu-cycle t)
    (setopt corfu-on-exact-match nil))

  (with-eval-after-load 'indent
    ;; config
    (setopt tab-always-indent 'complete))
#+end_src
*** cape
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(cape-file
                       cape-dabbrev
                       cape-elisp-block
                       cape-history
                       cape-keyword) "cape" nil t)

  (with-eval-after-load 'minibuffer
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-elisp-block)
    (add-to-list 'completion-at-point-functions #'cape-history))
#+end_src
*** prescient
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(prescient-persist-mode) "prescient" nil t)

  (add-hook 'emacs-startup-hook #'prescient-persist-mode)

  (with-eval-after-load 'prescient
    ;; config
    (setopt prescient-aggressive-file-save t))
#+end_src
*** kind-icon
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(kind-icon-margin-formatter) "kind-icon" nil t)

  (with-eval-after-load 'corfu
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src
** Git
*** magit
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-git-commit-mode) "git-commit" nil t)
  (autoload-if-found '(magit-status magit-blame) "magit")

  (add-hook 'emacs-startup-hook #'global-git-commit-mode)

  (keymap-global-set "C-x g" #'my/magit-status)
  (keymap-global-set "C-x G" #'magit-blame)

  (defun my/magit-status ()
    (interactive)
    (let ((default-directory (locate-dominating-file default-directory ".git")))
      (magit-status)))

  (with-eval-after-load 'magit
    ;; config
    (setopt magit-refresh-status-buffer nil))

  (with-eval-after-load 'magit-status
    ;; config
    (setopt magit-status-sections-hook
            '(magit-insert-status-headers
              ;; magit-insert-merge-log
              ;; magit-insert-rebase-sequence
              ;; magit-insert-am-sequence
              ;; magit-insert-sequencer-sequence
              ;; magit-insert-bisect-output
              ;; magit-insert-bisect-rest
              ;; magit-insert-bisect-log
              magit-insert-untracked-files
              magit-insert-unstaged-changes
              magit-insert-staged-changes
              ;; magit-insert-stashes
              magit-insert-unpushed-to-pushremote
              magit-insert-unpushed-to-upstream-or-recent
              magit-insert-unpulled-from-pushremote
              magit-insert-unpulled-from-upstream))


    ;; keybinds
    (define-key magit-status-mode-map (kbd "C-j") #'magit-visit-thing))

  (with-eval-after-load 'magit-log
    ;; keybinds
    (define-key magit-log-mode-map (kbd "C-j") #'magit-visit-thing))

  (with-eval-after-load 'magit-mode
    ;; config
    (setopt magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1))
#+END_SRC
*** git-gutter
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(git-gutter-mode) "git-gutter" nil t)

  (with-eval-after-load 'git-gutter
    ;; config
    (setopt git-gutter:update-hooks '(after-save-hook after-revert-hook)))
#+end_src
*** git-gutter-fringe
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(git-gutter-fr:init
                       git-gutter-fr:view-diff-infos
                       git-gutter-fr:clear) "git-gutter-fringe" nil t)

  (with-eval-after-load 'git-gutter
    ;; config
    (setopt git-gutter-fr:side 'right-fringe)
    (setopt git-gutter:window-width -1)
    (setopt git-gutter:init-function #'git-gutter-fr:init)
    (setopt git-gutter:view-diff-function #'git-gutter-fr:view-diff-infos)
    (setopt git-gutter:clear-function #'git-gutter-fr:clear))
#+end_src
*** git-timemachine
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(git-timemachine) "git-timemachine" nil t)
#+end_src
*** gist
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(gist-mode) "gist" nil t)
#+end_src
*** blamer
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(blamer-mode) "blamer" nil t)
#+end_src
*** git-auto-commit-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(git-auto-commit-mode) "git-auto-commit-mode" nil t)

  (with-eval-after-load 'git-auto-commit-mode
    ;; config
    (setopt gac-automatically-push-p t)
    (setopt gac-silent-message-p t)
    (setopt gac-debounce-interval (* 60 60 3))
    (setopt gac-default-message "Update"))
#+end_src
** Keyboard
*** key-chord
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(key-chord-mode key-chord-define-global) "key-chord" nil t)

  (add-hook 'emacs-startup-hook #'key-chord-mode)
  (add-hook 'emacs-startup-hook #'(lambda ()
                                 (key-chord-define-global "fj" #'view-mode)
                                 (key-chord-define-global "jf" #'view-mode)))
#+end_src
*** key-combo
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(key-combo-mode key-combo-define-local) "key-combo" nil t)

  ;; for php-mode
  (with-eval-after-load 'php-mode
    ;; (add-hook 'php-mode-hook
    ;;           #'(lambda ()
    ;;               (key-combo-mode)
    ;;               (when (window-system)
    ;;                 (key-combo-define-local (kbd ",>") " => "))
    ;;               ;; (key-combo-define-local (kbd "+") '("+" " + " "++" " ++ "))
    ;;               ;; (key-combo-define-local (kbd "-") '("-" " - " "--" " -- "))
    ;;               ;; (key-combo-define-local (kbd "*") '("*" "**" " * "))
    ;;               ;; (key-combo-define-local (kbd "=") '("=" " = " "==" "==="))
    ;;               ))
    )

  ;; for typescript-tsx-mode
  (with-eval-after-load 'typescript-tsx-mode
    ;; hooks
    (add-hook 'typescript-tsx-mode
              #'(lambda ()
                  (key-combo-mode)
                  (key-combo-define-local (kbd "</") #'web-mode-element-close))))
#+end_src
*** which-key
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(which-key-mode) "which-key" nil t)

  (add-hook 'emacs-startup-hook #'which-key-mode)
#+end_src
*** dmacro
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-dmacro-mode) "dmacro" nil t)

  (add-hook 'emacs-startup-hook #'global-dmacro-mode)
#+end_src
*** god-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(god-mode) "god-mode" nil t)
#+end_src
** Refactor
*** emr
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(emr-show-refactor-menu) "emr" nil t)

  (with-eval-after-load 'prog-mode
    ;; keybinds
    (define-key prog-mode-map (kbd "M-RET") #'emr-show-refactor-menu))
#+END_SRC
** Snippet
*** yasnippet
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(yas-global-mode) "yasnippet" nil t)

  (add-hook 'emacs-startup-hook #'yas-global-mode)
#+end_src
*** consult-yasnippet
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(consult-yasnippet) "consult-yasnippet" nil t)

  (keymap-global-set "C-c y" #'consult-yasnippet)
  (keymap-global-set "C-c C-y" #'consult-yasnippet)
#+end_src
** Narrowing
*** fancy-narrow
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(fancy-narrow-mode) "fancy-narrow" nil t)

  ;; (with-eval-after-load 'org
  ;;   (add-hook 'org-mode-hook #'fancy-narrow-local-mode))

  ;; (with-eval-after-load 'elisp-mode
  ;;   (add-hook 'emacs-lisp-mode-hook #'fancy-narrow-local-mode))

  ;; (with-eval-after-load 'lisp-mode
  ;;   (add-hook 'lisp-mode-hook #'fancy-narrow-local-mode))
#+end_src
*** origami
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-origami-mode origami-recursively-toggle-node origami-recursively-toggle-node) "origami" nil t)

  (keymap-global-set "C-c t" #'origami-recursively-toggle-node)
  (keymap-global-set "C-c C-t" #'origami-recursively-toggle-node)

  (add-hook 'emacs-startup-hook #'global-origami-mode)
#+end_src
** LSP
*** eglot
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eglot) "eglot" nil t)

  (with-eval-after-load 'eglot
    ;; config
    (setopt eglot-events-buffer-size nil)
    (setopt eglot-autoshutdown t)
    (setopt eglot-extend-to-xref t))
#+end_src
*** eglot-booster
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eglot-booster-mode) "eglot-booster" nil t)
#+end_src
*** lsp-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lsp lsp-deferred lsp-org lsp-register-client make-lsp-client) "lsp-mode" nil t)
  (autoload-if-found '(lsp-lens-mode lsp-lens-refresh lsp-lens--enable) "lsp-lens" nil t)
  (autoload-if-found '(lsp-modeline-workspace-status-mode) "lsp-modeline" nil t)
  (autoload-if-found '(lsp-headerline-breadcrumb-mode) "lsp-headerline" nil t)
  (autoload-if-found '(lsp-diagnostics-mode) "lsp-diagnostics" nil t)

  (with-eval-after-load 'lsp-mode
    (add-to-list 'lsp-language-id-configuration '("php-ts-mode" . "php"))

    ;; advice
    (advice-add 'lsp-rename :around #'my/advice-disable-buffer-readonly)

    ;; ignore path
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]vendor")
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]storage")
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]docs")
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]target")
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\].calva")
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\].clj-kondo")
    (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\].direnv")

    ;; enable flycheck
    (add-hook 'lsp-mode-hook #'flycheck-mode)

    ;; enable diagnostics
    (add-hook 'lsp-configure-hook #'lsp-diagnostics-mode)

    ;; config
    (setopt lsp-idle-delay 0.8)
    (setopt lsp-enable-links nil)
    (setopt lsp-log-io nil)
    (setopt lsp-file-watch-threshold 20000))

  (with-eval-after-load 'lsp-diagnostics
    ;; config
    (setopt lsp-diagnostics-flycheck-default-level 'info))

  (with-eval-after-load 'lsp-completion
    ;; config
    (setopt lsp-completion-no-cache t)
    (setopt lsp-prefer-capf t))

  (with-eval-after-load 'lsp-php
    ;; for intelephense
    (setopt lsp-intelephense-telemetry-enabled t)
    (setopt lsp-intelephense-files-exclude ["**/.git/**" "**/.svn/**" "**/.hg/**" "**/CVS/**" "**/.DS_Store/**"
                                            "**/node_modules/**" "**/bower_components/**" "**/vendor/**/{Test,test,Tests,tests}/**"
                                            "**/.direnv/**"]))

  (with-eval-after-load 'lsp-javascript
    ;; for typescript-language-server
    (setopt lsp-clients-typescript-log-verbosity "info")
    (setopt lsp-typescript-references-code-lens-enabled t)
    (setopt lsp-typescript-implementations-code-lens-enabled t)
    (setopt lsp-javascript-display-return-type-hints t)
    (setopt lsp-javascript-display-parameter-type-hints t)
    (setopt lsp-javascript-display-parameter-name-hints-when-argument-matches-name t)
    (setopt lsp-javascript-display-property-declaration-type-hints t)
    (setopt lsp-javascript-display-variable-type-hints t))

  (with-eval-after-load 'lsp-completion
    ;; config
    (setopt lsp-completion-provider :none))

  (with-eval-after-load 'lsp-ruby
    ;; config
    (setopt lsp-solargraph-autoformat t)
    (setopt lsp-solargraph-multi-root nil))

  (with-eval-after-load 'lsp-nil
    ;; config
    (setopt lsp-nix-nil-max-mem 100000))

  (with-eval-after-load 'lsp-copilot
    ;; config
    (setopt lsp-copilot-enabled nil))
#+END_SRC
*** emacs-lsp-booster

https://github.com/blahgeek/emacs-lsp-booster?tab=readme-ov-file#configure-lsp-mode

#+begin_src emacs-lisp :tangle yes
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
    "Try to parse bytecode instead of json."
    (or
     (when (equal (following-char) ?#)
       (let ((bytecode (read (current-buffer))))
         (when (byte-code-function-p bytecode)
           (funcall bytecode))))
     (apply old-fn args)))

  (advice-add (if (progn (require 'json)
                         (fboundp 'json-parse-buffer))
                  'json-parse-buffer
                'json-read)
              :around
              #'lsp-booster--advice-json-parse)

  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
    "Prepend emacs-lsp-booster command to lsp CMD."
    (let ((orig-result (funcall old-fn cmd test?)))
      (if (and (not test?)                             ;; for check lsp-server-present?
               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
               lsp-use-plists
               (not (functionp 'json-rpc-connection))  ;; native json-rpc
               (executable-find "emacs-lsp-booster"))
          (progn
            (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
              (setcar orig-result command-from-exec-path))
            (message "Using emacs-lsp-booster for %s!" orig-result)
            (cons "emacs-lsp-booster" orig-result))
        orig-result)))

  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src
*** emacs-ccls
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'lsp-mode
    (add-hook 'lsp-mode-hook #'(lambda () (require 'ccls))))
#+end_src
*** lsp-php-key
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'lsp-php
    (setopt lsp-intelephense-licence-key "00OXTX8OROOJH9P"))
#+end_src
*** consult-lsp
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(consult-lsp-symbols) "consult-lsp" nil t)

  (with-eval-after-load 'lsp-mode
    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols))
#+end_src
*** lsp-treemacs
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lsp-treemacs-sync-mode) "lsp-treemacs" nil t)

  (with-eval-after-load 'lsp-mode
    ;; hooks
    (add-hook 'lsp-mode-hook #'lsp-treemacs-sync-mode))

  (with-eval-after-load 'lsp-treemacs
    ;; config
    (setopt lsp-treemacs-error-list-severity 1)
    (setopt lsp-treemacs-error-list-current-project-only t))
#+end_src
*** lsp-dart
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'lsp-mode
    (add-hook 'lsp-mode-hook #'(lambda ()
                               (require 'lsp-dart))))
#+end_src
*** dap-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dap-debug) "dap-mode" nil t)
  (autoload-if-found '(dap-hydra) "dap-hydra" nil t)
  (autoload-if-found '(dap-ui-mode dap-ui-controls-mode) "dap-ui" nil t)
  (autoload-if-found '(dap-tooltip-mode) "dap-mouse" nil t)
  (autoload-if-found '(dap-php-setup) "dap-php" nil t)
  (autoload-if-found '(dap-node-setup) "dap-node" nil t)
  (autoload-if-found '(dap-go-setup) "dap-go" nil t)
  (autoload-if-found '(dap-ruby-setup) "dap-ruby" nil t)

  (with-eval-after-load 'dap-mode
    ;; keybind
    (define-key dap-mode-map (kbd "C-c d") #'dap-breakpoint-toggle)

    ;; hooks
    (add-hook 'dap-mode-hook #'dap-ui-mode)
    (add-hook 'dap-mode-hook #'dap-ui-controls-mode)
    (add-hook 'dap-mode-hook #'tooltip-mode)
    (add-hook 'dap-mode-hook #'dap-tooltip-mode)
    (add-hook 'dap-stopped-hook #'(lambda (arg) (call-interactively #'dap-hydra))))

  ;; (with-eval-after-load 'php-mode
  ;;   ;; hooks
  ;;   (add-hook 'php-mode-hook #'dap-php-setup))

  ;; (with-eval-after-load 'dap-php
  ;;   ;; config
  ;;   (setopt dap-php-debug-path `,(expand-file-name "xdebug/vscode-php-debug" dap-utils-extension-path))

  ;;   ;; register
  ;;   (dap-register-debug-template "Laravel Run Configuration"
  ;;                                (list :type "php"
  ;;                                      :request "launch"
  ;;                                      :mode "remote"
  ;;                                      :host "localhost"
  ;;                                      :port 9003)))

  ;; (with-eval-after-load 'go-mode
  ;;   ;; hooks
  ;;   (add-hook 'go-mode-hook #'dap-go-setup))

  ;; (with-eval-after-load 'ruby-mode
  ;;   ;; hooks
  ;;   (add-hook 'ruby-mode-hook #'dap-ruby-setup))
#+END_SRC
*** lsp-ui
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lsp-ui-mode) "lsp-ui" nil t)

  ;; hook
  (with-eval-after-load 'lsp-mode
    ;; hooks
    (add-hook 'lsp-mode-hook #'lsp-ui-mode))

  ;; lsp-ui-doc
  (with-eval-after-load 'lsp-ui-doc
    ;; config
    (setopt lsp-ui-doc-enable t)
    (setopt lsp-ui-doc-show-with-cursor t)
    (setopt lsp-ui-doc-use-webkit t)
    (setopt lsp-ui-doc-include-signature t)
    (setopt lsp-ui-doc-delay 1)
    (setopt lsp-ui-doc-max-height 30))

  ;; lsp-ui-peek
  (autoload-if-found '(lsp-ui-peek-find-references lsp-ui-peek-find-definitions lsp-ui-peek-find-implementation) "lsp-ui-peek" nil t)
  (with-eval-after-load 'lsp-ui-peek
    ;; config
    (setopt lsp-ui-peek-enable nil)
    (setopt lsp-ui-peek-peek-height 30)
    (setopt lsp-ui-peek-list-width 60)
    (setopt lsp-ui-peek-fontify 'on-demand))

  ;; lsp-ui-imenu
  (autoload-if-found '(lsp-ui-imenu) "lsp-ui-imenu" nil t)
  (with-eval-after-load 'lsp-ui-imenu
    ;; config
    (setopt lsp-ui-imenu-enable nil)
    (setopt lsp-ui-imenu-kind-position 'top))

  ;; lsp-ui-sideline
  (autoload-if-found '(lsp-ui-sideline-mode) "lsp-ui-sideline" nil t)
  (with-eval-after-load 'lsp-ui-sideline
    ;; config
    (setopt lsp-ui-sideline-enable nil)
    (setopt lsp-ui-sideline-show-hover t))

  ;; keybind
  (with-eval-after-load 'lsp-mode
    ;; hooks
    (define-key lsp-mode-map (kbd "C-c C-r") #'lsp-ui-peek-find-references)
    (define-key lsp-mode-map (kbd "C-c C-j") #'lsp-ui-peek-find-definitions)
    (define-key lsp-mode-map (kbd "C-c C-i") #'lsp-ui-peek-find-implementation)
    (define-key lsp-mode-map (kbd "C-c C-m") #'lsp-ui-imenu)
    (define-key lsp-mode-map (kbd "C-c C-s") #'lsp-ui-sideline-mode)
    (define-key lsp-mode-map (kbd "C-c C-d") #'lsp-ui-doc-mode))
#+END_SRC
*** lsp-scheme
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lsp-scheme) "lsp-scheme" nil t)

  (with-eval-after-load 'scheme
    (add-hook 'scheme-mode-hook #'lsp-scheme))
#+end_src
*** lsp-bridge
#+begin_src emacs-lisp :tangle yes
  ;; (autoload-if-found '(lsp-bridge-mode) "lsp-bridge" nil t)

  ;; (with-eval-after-load 'lsp-bridge
  ;;     ;; keybind
  ;;   (define-key lsp-bridge-mode-map (kbd "M-.") #'lsp-bridge-find-impl)
  ;;   (define-key lsp-bridge-mode-map (kbd "C-c C-r") #'lsp-bridge-find-references))
#+end_src
** Syntax
*** syntax-subword
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-syntax-subword-mode) "syntax-subword" nil t)

  (add-hook 'emacs-startup-hook #'global-syntax-subword-mode)
#+end_src
** Undo
*** undo-tree
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-undo-tree-mode) "undo-tree" nil t)

  (add-hook 'emacs-startup-hook #'global-undo-tree-mode)

  (with-eval-after-load 'undo-tree
    (setopt undo-tree-auto-save-history nil))
#+end_src
** View Mode
*** view-mode
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'prog-mode
    (add-hook 'prog-mode-hook #'view-mode))

  (with-eval-after-load 'view
    ;; hooks
    (add-hook 'view-mode-hook #'my/enable-view-mode-automatically)

    ;; keybind
    (define-key view-mode-map (kbd "f") #'forward-char)
    (define-key view-mode-map (kbd "b") #'backward-char)
    (define-key view-mode-map (kbd "n") #'my/org-view-next-heading)
    (define-key view-mode-map (kbd "p") #'my/org-view-previous-heading)
    (define-key view-mode-map (kbd "@") #'set-mark-command)
    (define-key view-mode-map (kbd "C-c '") #'my/org-edit-special)
    (define-key view-mode-map (kbd "C-c C-C") #'my/org-ctrl-c-ctrl-c)
    (define-key view-mode-map (kbd "e") nil)
    (define-key view-mode-map (kbd "C-j") nil)
    (define-key view-mode-map (kbd "C-i") #'my/view-tab)
    (define-key view-mode-map (kbd "S-C-i") #'my/view-shifttab)

    ;; functions
    (defun my/org-view-next-heading ()
      (interactive)
      (if (and (derived-mode-p 'org-mode)
               (org-at-heading-p))
          (org-next-visible-heading 1)
        (next-line)))

    (defun my/org-view-previous-heading ()
      (interactive)
      (if (and (derived-mode-p 'org-mode)
               (org-at-heading-p))
          (org-previous-visible-heading 1)
        (previous-line)))

    (defun my/view-tab ()
      (interactive)
      (when (and (derived-mode-p 'org-mode)
                 (or (org-at-heading-p)
                     (org-at-property-drawer-p)))
        (let ((view-mode nil))
          (org-cycle))))

    (defun my/view-shifttab ()
      (interactive)
      (when (derived-mode-p 'org-mode)
        (let ((view-mode nil))
          (org-shifttab))))

    (defun my/org-edit-special ()
      (interactive)
      (when (derived-mode-p 'org-mode)
        (view-mode -1)
        (org-edit-special)))

    (defun my/org-ctrl-c-ctrl-c ()
      (interactive)
      (when (derived-mode-p 'org-mode)
        (view-mode -1)
        (org-ctrl-c-ctrl-c)))

    (defvar my/view-mode-timer nil)
    (defun my/enable-view-mode-automatically ()
      (if view-mode
          (when my/view-mode-timer
            (cancel-timer my/view-mode-timer))
        (setopt my/view-mode-timer (run-with-idle-timer (* 60 10) nil #'view-mode))))

    (defun my/disable-buffer-readonly ()
      (setq-local buffer-read-only nil))

    (defun my/advice-disable-buffer-readonly (old-func &rest args)
      (add-hook 'view-mode-hook #'my/disable-buffer-readonly)
      (apply old-func args)
      (remove-hook 'view-mode-hook #'my/disable-buffer-readonly))

    ;; advices
    (advice-add 'view--disable :before #'(lambda (&rest _) (view-lock-mode -1))))
#+end_src
**** view-lock-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(view-lock-timer-start view-lock-quit) "view-lock-mode" nil t)

  (with-eval-after-load 'view
    (add-hook 'view-mode-hook #'view-lock-timer-start))

  (with-eval-after-load 'view-lock-mode
    (setopt view-lock-start-time (* 30 60)))
#+end_src
** Utility
*** comint
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'comint
    (setopt comint-buffer-maximum-size 100000)
    (setopt comint-prompt-read-only t)
    (setopt comint-terminfo-terminal "eterm-256color"))
#+end_src
*** crux
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(crux-open-with
                       crux-smart-open-line-above
                       crux-cleanup-buffer-or-region
                       crux-view-url
                       crux-transpose-windows
                       crux-duplicate-current-line-or-region
                       crux-duplicate-and-comment-current-line-or-region
                       crux-rename-file-and-buffer
                       crux-visit-term-buffer
                       crux-kill-other-buffers
                       crux-indent-defun
                       crux-top-join-lines
                       crux-kill-line-backwards) "crux" nil t)

  ;; keybind
  (keymap-global-set "C-c o" #'crux-open-with)
  (keymap-global-set "C-S-o" #'crux-smart-open-line-above)
  (keymap-global-set "C-c u" #'crux-view-url)
  (keymap-global-set "C-x 4 t" #'crux-transpose-windows)
  (keymap-global-set "C-c d" #'crux-duplicate-current-line-or-region)
  (keymap-global-set "C-c M-d" #'crux-duplicate-and-comment-current-line-or-region)
  (keymap-global-set "C-c r" #'crux-rename-file-and-buffer)
  (keymap-global-set "C-c M-t" #'crux-visit-term-buffer)
  (keymap-global-set "C-c k" #'crux-kill-other-buffers)
  (keymap-global-set "C-M-z" #'crux-indent-defun)
  (keymap-global-set "C-^" #'crux-top-join-lines)
  (keymap-global-set "C-DEL" #'crux-kill-line-backwards)
#+end_src
*** delsel
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(delete-selection-mode) "delsel" nil t)

  (add-hook 'emacs-startup-hook #'delete-selection-mode)
#+end_src
*** dogears
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dogears-go
                       dogears-back
                       dogears-forward
                       dogears-list
                       dogears-sidebar) "dogears" nil t)

  (keymap-global-set "M-g d" #'dogears-go)
  (keymap-global-set "M-g M-b" #'dogears-back)
  (keymap-global-set "M-g M-f" #'dogears-forward)
  (keymap-global-set "M-g M-d" #'dogears-list)
  (keymap-global-set "M-g M-D" #'dogears-sidebar)
#+end_src
*** goto-addr
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(goto-address-prog-mode goto-address-mode) "goto-address" nil t)

  (with-eval-after-load 'prog-mode
    (add-hook 'prog-mode-hook #'goto-address-prog-mode))

  (with-eval-after-load 'text-mode
    (add-hook 'text-mode-hook #'goto-address-mode))
#+END_SRC
*** minimap
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(minimap-mode) "minimap" nil t)

  (keymap-global-set "C-c m" #'minimap-mode)

  (with-eval-after-load 'minimap
    (setopt minimap-window-location 'right)
    (setopt minimap-update-delay 0.2)
    (setopt minimap-minimum-width 20)
    (setopt minimap-major-modes '(prog-mode org-mode)))
#+end_src
*** puni
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(puni-global-mode puni-disable-puni-mode) "puni" nil t)

  (add-hook 'emacs-startup-hook #'puni-global-mode)

  (with-eval-after-load 'lisp-mode
    (add-hook 'lisp-mode-hook #'puni-disable-puni-mode))

  (with-eval-after-load 'emacs-lisp-mode
    (add-hook 'emacs-lisp-mode-hook #'puni-disable-puni-mode))

  (with-eval-after-load 'clojure-mode
    (add-hook 'clojure-mode-hook #'puni-disable-puni-mode))

  (with-eval-after-load 'lisp-interaction-mode
    (add-hook 'lisp-interacton-mode-hook #'puni-disable-puni-mode))

  (with-eval-after-load 'scheme
    (add-hook 'scheme-mode-hook #'puni-disable-puni-mode))

  (with-eval-after-load 'simple
    (add-hook 'eval-expression-minibuffer-setup-hook #'puni-disable-puni-mode))

  (with-eval-after-load 'ielm
    (add-hook 'inferior-emacs-lisp-mode-hook #'puni-disable-puni-mode))

  (with-eval-after-load 'minibuffer
    (add-hook 'minibuffer-mode-hook #'puni-disable-puni-mode))
#+end_src
*** quickrun
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(quickrun) "quickrun" nil t)
#+end_src
*** restclient
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(restclient-mode) "restclient" nil t)
#+end_src
*** smart-jump
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(smart-jump-setup-default-registers) "smart-jump" nil t)

  (add-hook 'emacs-startup-hook #'smart-jump-setup-default-registers)
#+end_src
*** string-inflection
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(string-inflection-all-cycle) "string-inflection" nil t)
#+end_src
*** uuid
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(uuid-string) "uuid" nil t)

  (defun my/uuid ()
    (interactive)
    (insert (uuid-string)))
#+end_src
*** woman
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(woman woman-find-file) "woman" nil t)
#+end_src
* Remote Access
** tramp
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(tramp-set-completion-function) "tramp" nil t)
#+end_src
** docker-tramp
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(docker-tramp-add-method
                       docker-tramp-cleanup
                       docker-tramp-add-method) "docker-tramp" nil t)

  (add-hook 'emacs-startup-hook #'docker-tramp-add-method)

  (with-eval-after-load 'tramp
    (docker-tramp-add-method)
    (tramp-set-completion-function docker-tramp-method docker-tramp-completion-function-alist))
#+end_src
** consult-tramp
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(consult-tramp) "consult-tramp" nil t)
#+end_src
* Monitor
** Process
*** proced
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(proced) "proced" nil t)

  (with-eval-after-load 'proced
    ;; hooks
    (add-hook 'proced-mode-hook #'proced-toggle-auto-update)

    ;; config
    (setopt proced-auto-update-interval 10)
    (setopt proced-tree-flag t)
    (setopt proced-format 'long))
#+end_src
*** proced-narrow
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(proced-narrow) "proced-narrow" nil t)

  (with-eval-after-load 'proced
    ;; keybinds
    (define-key proced-mode-map (kbd "/") #'proced-narrow))
#+end_src
** System
*** symon
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(symon-mode) "symon" nil t)
#+end_src
** Minor Modes
*** command-log-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(clm/toggle-command-log-buffer) "command-log-mode" nil t)

  (defalias 'command-log #'clm/toggle-command-log-buffer)
#+end_src
** Statistics
*** esup
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(esup) "esup" nil t)
#+END_SRC
*** explain-pause-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(explain-pause-mode) "explain-pause-mode" nil t)
#+end_src
*** disk-usage
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(disk-usage disk-usage-here) "disk-usage" nil t)
#+end_src
*** keyfreq
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(keyfreq-mode keyfreq-autosave-mode) "keyfreq" nil t)

  (add-hook 'emacs-startup-hook #'keyfreq-mode)
  (add-hook 'emacs-startup-hook #'keyfreq-autosave-mode)
#+end_src
*** uptimes
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(uptimes) "uptimes" nil t)
#+end_src
* EWW
** basic
#+begin_src emacs-lisp :tangle yes
  (defun my/eww-rename-buffer ()
    "Rename the name of current EWW buffer."
    (let* ((title (plist-get eww-data :title))
           (url (file-name-base (eww-current-url)))
           (buffer-name (or (if (and title (> (length title) 0))
                                title
                              nil)
                            url "")))
      (rename-buffer (format "eww: %s" buffer-name) t)))

  (with-eval-after-load 'eww
    ;; config
    (setopt eww-header-line-format nil)
    (setopt eww-search-prefix "http://www.google.co.jp/search?q="))

  (with-eval-after-load 'eww
    ;; keybind
    (define-key eww-mode-map (kbd "C") #'eww-set-character-encoding)
    (define-key eww-mode-map (kbd "C-j") #'eww-follow-link)
    (define-key eww-mode-map (kbd "T") #'eww-goto-title-heading)
    (define-key eww-mode-map (kbd "T") #'eww-goto-title-heading))

  (with-eval-after-load 'eww
    ;; hooks
    (add-hook 'eww-after-render #'my/eww-rename-buffer))
#+end_src
** eww-lnum
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eww-lnum-follow eww-lnum-universal) "eww-lnum" nil t)

  (with-eval-after-load 'eww
    ;; keybinds
    (define-key eww-mode-map "f" #'eww-lnum-follow)
    (define-key eww-mode-map "F" #'eww-lnum-universal))
#+end_src
* Dired
** basic
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'dired
    ;; config
    (setopt dired-dwim-target nil)
    (setopt dired-hide-details-hide-symlink-targets nil)
    (setopt dired-listing-switches "-alh")
    (setopt dired-recursive-copies 'always)
    (setopt dired-use-ls-dired nil))
#+end_src
** dired-collapse
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dired-collapse-mode) "dired-collapse" nil t)

  (with-eval-after-load 'dired
    ;; hooks
    (add-hook 'dired-mode #'dired-collapse-mode))
#+end_src
** dired-filter
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dired-filter-mode) "dired-filter" nil t)

  (with-eval-after-load 'dired
    ;; hooks
    (add-hook 'dired-mode #'dired-filter-mode))
#+end_src
** dired-narrow
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dired-narrow-mode) "dired-narrow" nil t)

  (with-eval-after-load 'dired
    ;; hooks
    (add-hook 'dired-mode-hook #'dired-narrow-mode))
#+end_src
** dired-open
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dired-open-file) "dired-open" nil t)

  (with-eval-after-load 'dired
    ;; keybind
    (define-key dired-mode-map [remap dired-find-file] #'dired-open-file))
#+end_src
** dired-ranger
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '() "dired-ranger" nil t)
#+end_src
** dired-quick-sort
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dired-quick-sort-setup) "dired-quick-sort" nil t)

  (with-eval-after-load 'dired
    ;; hooks
    (add-hook 'dired-mode-hook #'dired-quick-sort-setup))
#+end_src
** dired-subtree
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dired-subtree-apply-filter) "dired-subtree" nil t)
#+end_src
** diredfl
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(diredfl-global-mode) "diredfl" nil t)

  (with-eval-after-load 'dired
    ;; hooks
    (add-hook 'dired-mode-hook #'diredfl-global-mode))
#+end_src
* Search
** wgrep
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(wgrep-setup) "wgrep" nil t)

  (with-eval-after-load 'grep
    ;; hooks
    (add-hook 'grep-setup-hook 'wgrep-setup))
#+end_src
** consult
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(consult-bookmark
                       consult-buffer
                       consult-buffer-other-frame
                       consult-buffer-other-tab
                       consult-buffer-other-window
                       consult-complex-command
                       consult-find
                       consult-flycheck
                       consult-focus-lines
                       consult-git-grep
                       consult-global-mark
                       consult-goto-line
                       consult-grep
                       consult-history
                       consult-isearch-history
                       consult-keep-lines
                       consult-line
                       consult-line-multi
                       consult-locate
                       consult-man
                       consult-mark
                       consult-outline
                       consult-project-buffer
                       consult-register
                       consult-register-load
                       consult-register-store
                       consult-ripgrep
                       consult-yank-pop
                       consult-mode-command

                       ;; other
                       consult-completion-in-region
                       consult-preview-at-point-mode
                       consult-register-window) "consult" nil t)

  (autoload-if-found '(consult-compile-error) "consult-compile" nil t)
  (autoload-if-found '(consult-org-heading consult-org-agenda) "consult-org" nil t)
  (autoload-if-found '(consult-imenu consult-imenu-multi) "consult-imenu" nil t)
  (autoload-if-found '(consult-kmacro) "consult-kmacro" nil t)
  (autoload-if-found '(consult-xref) "consult-xref" nil t)

  ;; keybind
  ;; C-c bindings in `mode-specific-map'
  (keymap-global-set "C-c M-x" #'consult-mode-command)
  (keymap-global-set "C-c h" #'consult-history)

  ;; C-x bindings in `ctl-x-map'
  (keymap-global-set "C-x M-:" #'consult-complex-command)
  (keymap-global-set "C-x b" #'consult-buffer)
  (keymap-global-set "C-x 4 b" #'consult-buffer-other-window)
  (keymap-global-set "C-x 5 b" #'consult-buffer-other-frame)

  ;; Other custom bindings
  (keymap-global-set "M-y" #'consult-yank-pop)

  ;; M-g bindings in `goto-map'
  (keymap-global-set "M-g e" #'consult-compile-error)
  (keymap-global-set "M-g f" #'consult-flycheck)
  (keymap-global-set "M-g g" #'consult-goto-line)
  (keymap-global-set "M-g M-g" #'consult-goto-line)
  (keymap-global-set "M-g o" #'consult-outline)
  (keymap-global-set "M-g m" #'consult-mark)
  (keymap-global-set "M-g k" #'consult-global-mark)
  (keymap-global-set "M-g i" #'consult-imenu)
  (keymap-global-set "M-g I" #'consult-imenu-multi)

  ;; C-o bindings in `search-map'
  (keymap-global-set "C-o" #'(lambda ()
                               (interactive)
                               (let ((word (thing-at-point 'symbol 'no-properties)))
                                 (consult-line word))))

  ;; Isearch integration
  (with-eval-after-load 'isearch
    (define-key isearch-mode-map (kbd "M-e") #'consult-isearch-history))

  ;; Minibuffer history
  (with-eval-after-load 'minibuffer
    ;; config
    (setopt completion-in-region-function #'consult-completion-in-region)

    ;; keybinds
    (define-key minibuffer-local-map (kbd "M-s") #'consult-history)
    (define-key minibuffer-local-map (kbd "M-r") #'consult-history))

  (with-eval-after-load 'simple
    (add-hook 'completion-list-mode #'consult-preview-at-point-mode))

  (with-eval-after-load 'register
    (advice-add #'register-preview :override #'consult-register-window))

  (with-eval-after-load 'xref
    (setopt xref-show-xrefs-function #'consult-xref)
    (setopt xref-show-definitions-function #'consult-xref))
#+end_src
** affe
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(affe-grep) "affe" nil t)

  (with-eval-after-load 'affe
    ;; config
    (setopt affe-highlight-function 'orderless-highlight-matches)
    (setopt affe-find-command "fd --color=never --full-path")
    (setopt affe-regexp-function 'orderless-pattern-compiler))
#+end_src
** embark
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(embark-act embark-dwim embark-prefix-help-command) "embark" nil t)

  (keymap-global-set "C-." #'embark-act)
  (keymap-global-set "C-h B" #'embark-prefix-help-command)

  (with-eval-after-load 'embark
    ;; macros
    (defmacro my/embark-ace-action (fn)
      `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (aw-switch-to-window (aw-select nil))
           (call-interactively (symbol-function ',fn)))))

    (defmacro my/embark-split-action (fn split-type)
      `(defun ,(intern (concat "my/embark-"
                               (symbol-name fn)
                               "-"
                               (car (last (split-string
                                           (symbol-name split-type) "-"))))) ()
         (interactive)
         (funcall #',split-type)
         (call-interactively #',fn)))

    (defun my/sudo-find-file (file)
      "Open FILE as root."
      (interactive "FOpen file as root: ")
      (when (file-writable-p file)
        (user-error "File is user writeable, aborting sudo"))
      (find-file (if (file-remote-p file)
                     (concat "/" (file-remote-p file 'method) ":"
                             (file-remote-p file 'user) "@" (file-remote-p file 'host)
                             "|sudo:root@"
                             (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                   (concat "/sudo:root@localhost:" file))))

    ;; config
    (setopt embark-mixed-indicator-delay 0.1)
    (setopt prefix-help-command #'embark-prefix-help-command)

    ;; ace-window
    (define-key embark-file-map     (kbd "o") (my/embark-ace-action find-file))
    (define-key embark-buffer-map   (kbd "o") (my/embark-ace-action switch-to-buffer))
    (define-key embark-bookmark-map (kbd "o") (my/embark-ace-action bookmark-jump))

    ;; split window(2)
    (define-key embark-file-map     (kbd "2") (my/embark-split-action find-file split-window-below))
    (define-key embark-buffer-map   (kbd "2") (my/embark-split-action switch-to-buffer split-window-below))
    (define-key embark-bookmark-map (kbd "2") (my/embark-split-action bookmark-jump split-window-below))

    ;; split window(3)
    (define-key embark-file-map     (kbd "3") (my/embark-split-action find-file split-window-right))
    (define-key embark-buffer-map   (kbd "3") (my/embark-split-action switch-to-buffer split-window-right))
    (define-key embark-bookmark-map (kbd "3") (my/embark-split-action bookmark-jump split-window-right))

    ;; sudo
    (define-key embark-file-map (kbd "S") #'my/sudo-find-file)

    ;; ellama
    (define-key embark-general-map (kbd "L") #'ellama-transient-main-menu)

    ;; copilot-chat
    (define-key embark-general-map (kbd "C") #'copilot-chat-transient-code)

    ;; hooks
    (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode))
#+end_src
** compile-multi
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(compile-multi) "compile-multi" nil t)

  (keymap-global-set "C-x m" #'compile-multi)
#+end_src
** vertico
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(vertico-mode) "vertico-autoloads" nil t)

  (add-hook 'emacs-startup-hook #'vertico-mode)

  (with-eval-after-load 'vertico
    ;; config
    (setopt vertico-count 8)
    (setopt vertico-cycle t))
#+end_src
** marginalia
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(marginalia-mode marginalia-cycle) "marginalia" nil t)

  (add-hook 'emacs-startup-hook #'marginalia-mode)

  (with-eval-after-load 'minibuffer
    ;; config
    (setopt marginalia-align-offset 25)

    ;; hooks
    (define-key minibuffer-local-map (kbd "M-A") #'marginalia-cycle))
#+end_src
** orderless
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(orderless-all-completions orderless-try-completion) "orderless" nil t)

  (with-eval-after-load 'minibuffer
    ;; config
    (add-to-list 'completion-styles-alist '(orderless orderless-try-completion orderless-all-completions
                                                      "Completion of multiple components, in any order."))
    (setopt completion-styles '(orderless initials flex basic))
    (setopt completion-category-overrides '((file (styles flex basic partial-completion)))))
#+end_src
* Buffer
** auto-save-buffers-enhanced
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(auto-save-buffers-enhanced) "auto-save-buffers-enhanced" nil t)

  ;; (add-hook 'emacs-startup-hook #'auto-save-buffers-enhanced)

  (with-eval-after-load 'auto-save-buffers-enhanced
    (setopt auto-save-buffers-enhanced-interval 10))
#+end_src
** editorconfig
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(editorconfig-mode) "editorconfig" nil t)

  (add-hook 'emacs-startup-hook #'editorconfig-mode)
#+END_SRC
** popwin
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(popwin-mode) "popwin" nil t)

  (add-hook 'emacs-startup-hook #'popwin-mode)
#+end_src
** whitespace
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-whitespace-mode) "whitespace" nil t)

  (when window-system
    (add-hook 'emacs-startup-hook #'global-whitespace-mode))

  (with-eval-after-load 'whitespace
    ;; config
    (setopt whitespace-style '(face tabs tab-mark spaces space-mark))
    (setopt whitespace-display-mappings '((space-mark ?\u3000 [?\u25a1])
                                          (tab-mark ?\t [?\xBB ?\t] [?\\ ?\t]))))
#+END_SRC

* File
** recentf
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(recentf-mode) "recentf" nil t)

  (add-hook 'emacs-startup-hook #'recentf-mode)

  (with-eval-after-load 'recentf
    ;; config
    (setopt recentf-auto-cleanup 'never)
    (setopt recentf-max-menu-items 10000)
    (setopt recentf-max-saved-items 10000)
    (setopt recentf-save-file  "~/.emacs.d/.recentf")
    (setopt recentf-exclude '(".recentf" "\\.gpg\\")))
#+END_SRC
** open-junk-file
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(open-junk-file) "open-junk-file" nil t)

  (keymap-global-set "C-x j" #'open-junk-file)

  (with-eval-after-load 'open-junk-file
    ;; config
    (setopt open-junk-file-format "~/.emacs.d/.junk/%Y-%m-%d-%H%M%S."))
#+END_SRC
** vlf
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(vlf-disable-for-function) "vlf-setup" t)

  (with-eval-after-load 'dired
    ;; hooks
    (define-key dired-mode-map (kbd "V") #'dired-vlf))
#+end_src
** sudo-edit
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(sudo-edit-current-file) "sudo-edit" nil t)
#+end_src
* Project
** projectile
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(projectile-mode
                       projectile-clear-known-projects
                       projectile-cleanup-known-projects) "projectile" nil t)

  (add-hook 'emacs-startup-hook #'projectile-mode)
  (add-hook 'emacs-startup-hook #'my/update-projectile-known-projects)

  (defun my/update-projectile-known-projects ()
    (interactive)
    (projectile-clear-known-projects)
    (projectile-cleanup-known-projects)
    (setopt projectile-known-projects (mapcar
                                       (lambda (x)
                                         (abbreviate-file-name (concat x "/")))
                                       (split-string (shell-command-to-string "ghq list --full-path")))))
  (with-eval-after-load 'projectile
    ;; advice
    (advice-add 'projectile-switch-project :before #'my/update-projectile-known-projects)

    ;; keybind
    (keymap-global-set "M-p" #'projectile-command-map)
    (keymap-global-set "C-c p" #'projectile-command-map)

    ;; config
    (setopt projectile-switch-project-action 'projectile-dired)
    (setopt projectile-use-git-grep t))
#+end_src
** consult-projectile
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(consult-projectile-switch-to-buffer
                       consult-projectile-switch-to-buffer-other-window
                       consult-projectile-switch-to-buffer-other-frame
                       consult-projectile-find-dir
                       consult-projectile-find-file
                       consult-projectile-find-file-other-window
                       consult-projectile-find-file-other-frame
                       consult-projectile-recentf
                       consult-projectile-switch-project) "consult-projectile" nil t)

  (with-eval-after-load 'projectile
    ;; advice
    (advice-add 'projectile-switch-to-buffer :override #'consult-projectile-switch-to-buffer)
    (advice-add 'projectile-switch-to-buffer-other-window :override #'consult-projectile-switch-to-buffer-other-window)
    (advice-add 'projectile-switch-to-buffer-other-frame :override #'consult-projectile-switch-to-buffer-other-frame)
    (advice-add 'projectile-find-dir :override #'consult-projectile-find-dir)
    (advice-add 'projectile-find-file :override #'consult-projectile-find-file)
    (advice-add 'projectile-find-file-other-window :override #'consult-projectile-find-file-other-window)
    (advice-add 'projectile-find-file-other-frame :override #'consult-projectile-find-file-other-frame)
    (advice-add 'projectile-recentf :override #'consult-projectile-recentf)
    (advice-add 'projectile-switch-project :override #'consult-projectile-switch-project)

    ;; keybind
    (keymap-global-set "C-x C-b" #'consult-projectile-switch-to-buffer))
#+end_src

** projectile-git-autofetch
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(projectile-git-autofetch-setup) "projectile-git-autofetch" nil t)

  (add-hook 'emacs-startup-hook #'projectile-git-autofetch-setup)

  (with-eval-after-load 'projectile-git-autofetch
    ;; config
    (setopt projectile-git-autofetch-notify nil)
    (setopt projectile-git-autofetch-interval 180))
#+end_src
* Window
** ace-window
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ace-window) "ace-window" nil t)

  (keymap-global-set "C-x o" #'ace-window)

  (with-eval-after-load 'ace-window
    ;; config
    (setopt aw-dispatch-always t)
    (setopt aw-scope 'frame)
    (setopt aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (setopt aw-minibuffer-flag t))
#+end_src
** writeroom-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(writeroom-mode
                       writeroom-decrease-width
                       writeroom-increase-width
                       writeroom-adjust-width
                       writeroom-width)
                     "writeroom-mode" nil t)

  (with-eval-after-load 'writeroom-mode
    ;; keybind
    (define-key writeroom-mode-map (kbd "C-M-<") #'writeroom-decrease-width)
    (define-key writeroom-mode-map (kbd "C-M->") #'writeroom-increase-width)
    (define-key writeroom-mode-map (kbd "C-M-=") #'writeroom-adjust-width)

    ;; config
    (setq writeroom-width 150))
#+end_src
** zoom-window
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(zoom-window-zoom) "zoom-window" nil t)

  (keymap-global-set "C-c C-z" #'zoom-window-zoom)
#+end_src
** tab-bar
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(tab-bar-mode
                       tab-bar-history-mode
                       tab-previous
                       tab-next) "tab-bar" nil t)

  (add-hook 'emacs-startup-hook #'tab-bar-history-mode)

  (keymap-global-set "C-x C-t" tab-prefix-map)
  (keymap-global-set "M-[" #'tab-previous)
  (keymap-global-set "M-]" #'tab-next)


  (with-eval-after-load 'tab-bar
    ;; rename tab-bar with projectile
    (define-key tab-prefix-map (kbd "r") #'my/tab-bar-rename-tab)

    ;; config
    (setq tab-bar-close-button-show nil)
    (setq tab-bar-close-last-tab-choice nil)
    (setq tab-bar-close-tab-select 'left)
    (setq tab-bar-history-mode nil)
    (setq tab-bar-new-tab-choice "*scratch*")
    (setq tab-bar-new-button-show nil)
    (setq tab-bar-tab-name-truncated-max 12)
    (setq tab-bar-separator " | ")

    ;; advice
    ;; close neotree when tab bar action
    (advice-add 'tab-new :before #'(lambda (&rest _) (neotree-hide)))
    (advice-add 'tab-next :before #'(lambda (&rest _) (neotree-hide)))
    (advice-add 'tab-bar-switch-to-tab :before #'(lambda (&rest _) (neotree-hide)))

    ;; function
    (defun my/tab-bar-rename-tab ()
      (interactive)
      (let ((proj-name (projectile-project-name)))
        (tab-bar-rename-tab proj-name))))
#+end_src
* Cursor
** avy
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(avy-goto-char) "avy" nil t)

  (keymap-global-set "C-:" #'avy-goto-char)

  (with-eval-after-load 'avy
    ;; config
    (setopt avy-all-windows nil)
    (setopt avy-background t))
#+end_src
** avy-zap
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(avy-zap-up-to-char-dwim) "avy-zap" nil t)

  (keymap-global-set "M-z" #'avy-zap-up-to-char-dwim)
#+end_src
** expand-region
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(er/expand-region) "expand-region" nil t)

  (add-hook 'emacs-startup-hook #'transient-mark-mode)

  (keymap-global-set "C-M-@" #'er/expand-region)
#+end_src
** multiple-cursors
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(mc/mark-next-like-this mc/mark-previous-like-this mc/mark-all-like-this) "multiple-cursors" nil t)

  (keymap-global-set "C->" #'mc/mark-next-like-this)
  (keymap-global-set "C-<" #'mc/mark-previous-like-this)
  (keymap-global-set "C-c C-<" #'mc/mark-all-like-this)
#+END_SRC
* Client
** Mail
*** mu4e
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(mu4e) "mu4e" nil t)

  (keymap-global-set "C-x C-w" #'mu4e)

  (with-eval-after-load 'mu4e
    ;; config
    (setopt mail-user-agent 'mu4e-user-agent))

  (with-eval-after-load 'mu4e-update
    ;; config
    (setopt mu4e-get-mail-command "offlineimap")
    (setopt mu4e-update-interval (* 1 60))
    (setopt mu4e-index-cleanup nil)
    (setopt mu4e-index-lazy-check t))

  (with-eval-after-load 'mu4e-view
    ;; config
    (setopt mu4e-split-view 'horizontal))

  (with-eval-after-load 'mu4e-folders
    ;; config
    (setopt mu4e-maildir-shortcuts '((:maildir "/Gmail/INBOX" :key ?i)
                                     (:maildir "/Gmail/Emacs" :key ?e)
                                     (:maildir "/Gmail/GitHub" :key ?h)
                                     (:maildir "/Gmail/Guix" :key ?g)
                                     (:maildir "/Gmail/PHP" :key ?p))))

  (with-eval-after-load 'mm-decode
    (add-to-list 'mm-discouraged-alternatives "text/html")
    (add-to-list 'mm-discouraged-alternatives "text/richtext"))
#+end_src
*** mu4e-views
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '() "mu4e-views" nil t)
#+end_src
*** mu4e-dashboard
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(mu4e-dashboard) "mu4e-dashboard" nil t)

  (with-eval-after-load 'mu4e-dashboard
    ;; config
    (setopt mu4e-dashboard-file "~/.emacs.d/misc/mu4e-dashboard.org"))
#+end_src
** Googling
*** google-this
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(google-this) "google-this" nil t)
#+END_SRC
*** google-translate
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(google-translate-at-point) "google-translate" nil t)
#+end_src
** Client
*** md4rd
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(md4rd
                       md4rd-login
                       md4rd-visit
                       md4rd-widget-expand-all
                       md4rd-widget-collapse-all
                       md4rd-reply
                       md4rd-upvote
                       md4rd-downvote
                       md4rd-widget-toggle-line
                       md4rd-refresh-login
                       md4rd-indent-all-the-lines) "md4rd" nil t)

  (with-eval-after-load 'md4rd
    (add-hook 'md4rd-mode-hook #'md4rd-indent-all-the-lines)
    (run-with-timer 0 3540 #'md4rd-refresh-login)

    ;; config
    (setopt md4rd-subs-active '(emacs lisp+Common_Lisp prolog clojure))
    ;; (setopt md4rd--oauth-access-token "your-access-token-here")
    ;; (setopt md4rd--oauth-refresh-token "your-refresh-token-here")

    ;; keymap
    (define-key md4rd-mode-map (kbd "u") 'tree-mode-goto-parent)
    (define-key md4rd-mode-map (kbd "o") 'md4rd-open)
    (define-key md4rd-mode-map (kbd "v") 'md4rd-visit)
    (define-key md4rd-mode-map (kbd "e") 'tree-mode-toggle-expand)
    (define-key md4rd-mode-map (kbd "E") 'md4rd-widget-expand-all)
    (define-key md4rd-mode-map (kbd "C") 'md4rd-widget-collapse-all)
    (define-key md4rd-mode-map (kbd "n") 'widget-forward)
    (define-key md4rd-mode-map (kbd "j") 'widget-forward)
    (define-key md4rd-mode-map (kbd "h") 'backward-button)
    (define-key md4rd-mode-map (kbd "p") 'widget-backward)
    (define-key md4rd-mode-map (kbd "k") 'widget-backward)
    (define-key md4rd-mode-map (kbd "l") 'forward-button)
    (define-key md4rd-mode-map (kbd "q") 'kill-current-buffer)
    (define-key md4rd-mode-map (kbd "r") 'md4rd-reply)
    (define-key md4rd-mode-map (kbd "u") 'md4rd-upvote)
    (define-key md4rd-mode-map (kbd "d") 'md4rd-downvote)
    (define-key md4rd-mode-map (kbd "t") 'md4rd-widget-toggle-line))
#+end_src
* Theme
** Font
*** fontset
#+begin_src emacs-lisp :tangle yes
  (defconst my/enable-warning-log nil)

  (defun set-fontset-font:around (set-fontset-font name target font-spec &optional frame add)
    "Warn if specified font is not installed."
    (if (stringp font-spec)
        (setopt font-spec (font-spec :family font-spec)))
    (if (and (fontp font-spec)
             (null (find-font font-spec))
             my/enable-warning-log)
        (warn "set-fontset-font: font %s is not found." (font-get font-spec :family))
      (ignore-errors
        (funcall set-fontset-font name target font-spec frame add))))

  ;; reset all settings in default fontset
  (add-hook 'emacs-startup-hook
            #'(lambda ()
                (advice-add 'set-fontset-font :around #'set-fontset-font:around)

                (when (functionp 'set-fontset-font)
                  (if (find-font (font-spec :family "Noto Sans"))
                      (set-fontset-font t '(0 . #x3fffff) "Noto Sans"))

                  ;; multiple platform
                  (set-fontset-font t 'latin "Noto Sans")
                  (set-fontset-font t 'greek "Noto Sans")
                  (set-fontset-font t 'phonetic "Noto Sans")
                  (set-fontset-font t 'coptic "Noto Sans Coptic")
                  (set-fontset-font t 'coptic "Noto Sans Symbols2" nil 'append)
                  (set-fontset-font t 'cyrillic "Noto Sans")
                  (set-fontset-font t 'armenian "Noto Sans Armenian")
                  (set-fontset-font t 'hebrew "Noto Sans Hebrew")
                  (set-fontset-font t 'arabic "Noto Sans Arabic")
                  (set-fontset-font t 'syriac "Noto Sans Syriac")
                  (set-fontset-font t 'thaana "Noto Sans Thaana")
                  (set-fontset-font t 'nko "Noto Sans N'Ko")
                  (set-fontset-font t 'samaritan "Noto Sans Samaritan")
                  (set-fontset-font t 'mandaic "Noto Sans Mandaic")
                  (set-fontset-font t 'devanagari "Noto Sans Devanagari")
                  (set-fontset-font t 'bengali "Noto Sans Bengali")
                  (set-fontset-font t 'gurmukhi "Noto Sans Gurmukhi")
                  (set-fontset-font t 'gujarati "Noto Sans Gujanrati")
                  (set-fontset-font t 'oriya "Noto Sans Oriya")
                  (set-fontset-font t 'tamil "Noto Sans Tamil")
                  (set-fontset-font t 'tamil "Noto Sans Tamil Supplement" nil 'append)
                  (set-fontset-font t 'telugu "Noto Sans Telugu")
                  (set-fontset-font t 'kannada "Noto Sans Kannada")
                  (set-fontset-font t 'malayalam "Noto Sans Malayalam")
                  (set-fontset-font t 'sinhala "Noto Sans Sinhala")
                  (set-fontset-font t 'thai "Noto Sans Thai")
                  (set-fontset-font t 'lao "Noto Sans Lao")
                  (set-fontset-font t 'tibetan "Noto Sans Tibetan")
                  (set-fontset-font t 'burmese "Noto Sans Myanmar")
                  (set-fontset-font t 'georgian "Noto Sans Georgian")
                  (set-fontset-font t 'hangul "Noto Sans CJK KR")
                  (set-fontset-font t 'ethiopic "Noto Sans Ethiopic")
                  (set-fontset-font t 'cherokee "Noto Sans Cherokee")
                  (set-fontset-font t 'canadian-aboriginal "Noto Sans Canadian Aboriginal")
                  (set-fontset-font t 'ogham "Noto Sans Ogham")
                  (set-fontset-font t 'runic "Noto Sans Runic")
                  (set-fontset-font t 'tagalog "Noto Sans Tagalog")
                  (set-fontset-font t 'hanunoo "Noto Sans Hanunoo")
                  (set-fontset-font t 'buhid "Noto Sans Buhid")
                  (set-fontset-font t 'tagbanwa "Noto Sans Tagbanwa")
                  (set-fontset-font t 'khmer "Noto Sans Khmer")
                  (set-fontset-font t 'mongolian "Noto Sans Mongolian")
                  (set-fontset-font t 'limbu "Noto Sans Limbu")
                  (set-fontset-font t 'tai-le "Noto Sans Tai Le")
                  (set-fontset-font t 'tai-lue "Noto Sans NewTaiLue")
                  (set-fontset-font t 'buginese "Noto Sans Buginese")
                  (set-fontset-font t 'tai-tham "Noto Sans Tai Tham")
                  (set-fontset-font t 'balinese "Noto Sans Balinese")
                  (set-fontset-font t 'sundanese "Noto Sans Sundanese")
                  (set-fontset-font t 'vedic "Noto Sans Devanagari")
                  (set-fontset-font t 'symbol "Noto Sans CJK JP")
                  (set-fontset-font t 'symbol "Noto Sans Symbols2" nil 'append)
                  (set-fontset-font t 'symbol "Noto Sans" nil 'append)
                  (set-fontset-font t 'symbol "Noto Sans Math" nil 'append)
                  (set-fontset-font t 'symbol "Noto Emoji" nil 'append)
                  (set-fontset-font t 'symbol "Noto Sans Symbols" nil 'append)
                  (set-fontset-font t 'braille "Noto Sans Symbols2")
                  (set-fontset-font t 'batak "Noto Sans Batak")
                  (set-fontset-font t 'lepcha "Noto Sans Lepcha")
                  (set-fontset-font t 'ol-chiki "Noto Sans Ol Chiki")
                  (set-fontset-font t 'glagolitic "Noto Sans Glagolitic")
                  (set-fontset-font t 'tifinagh "Noto Sans Tifinagh")
                  (set-fontset-font t 'han "Noto Sans CJK JP")
                  (set-fontset-font t 'ideographic-description "Noto Sans CJK JP")
                  (set-fontset-font t 'cjk-misc "Noto Sans CJK JP")
                  (set-fontset-font t 'kana "Noto Sans CJK JP")
                  (set-fontset-font t 'bopomofo "Noto Sans CJK TC")
                  (set-fontset-font t 'kanbun "Noto Sans CJK JP")
                  (set-fontset-font t 'yi "Noto Sans Yi")
                  (set-fontset-font t 'lisu "Noto Sans Lisu")
                  (set-fontset-font t 'vai "Noto Sans Vai")
                  (set-fontset-font t 'bamum "Noto Sans Bamum")
                  (set-fontset-font t 'syloti-nagri "Noto Sans Syloti Nagri")
                  (set-fontset-font t 'north-indic-number "Noto Sans Devanagari")
                  (set-fontset-font t 'phags-pa "Noto Sans Phags Pa")
                  (set-fontset-font t 'saurashtra "Noto Sans Saurashtra")
                  (set-fontset-font t 'kayah-li "Noto Sans Kayah Li")
                  (set-fontset-font t 'rejang "Noto Sans Rejang")
                  (set-fontset-font t 'javanese "Noto Sans Javanese")
                  (set-fontset-font t 'cham "Noto Sans Cham")
                  (set-fontset-font t 'tai-viet "Noto Sans Tai Viet")
                  (set-fontset-font t 'meetei-mayek "Noto Sans Meetei Mayek")
                  (set-fontset-font t 'vertical-form "Noto Sans CJK JP")
                  (set-fontset-font t '(#xfe50 . #xfe6b) "Noto Sans CJK JP") ; symbol
                  (set-fontset-font t '(#xfff9 . #xfffb) "Noto Sans Symbols2") ; nil
                  (set-fontset-font t 'linear-b "Noto Sans Linear B")
                  (set-fontset-font t 'aegean-number "Noto Sans Linear B")
                  (set-fontset-font t 'ancient-greek-number "Noto Sans Symbols2")
                  (set-fontset-font t 'ancient-symbol "Noto Sans Symbols2")
                  (set-fontset-font t 'phaistos-disc "Noto Sans Symbols2")
                  (set-fontset-font t 'lycian "Noto Sans Lycian")
                  (set-fontset-font t 'carian "Noto Sans Carian")
                  (set-fontset-font t 'old-italic "Noto Sans Old Italic")
                  (set-fontset-font t 'gothic "Noto Sans Gothic")
                  (set-fontset-font t 'old-permic "Noto Sans Old Permic")
                  (set-fontset-font t 'ugaritic "Noto Sans Ugaritic")
                  (set-fontset-font t 'old-persian "Noto Sans OldPersian")
                  (set-fontset-font t 'deseret "Noto Sans Deseret")
                  (set-fontset-font t 'shavian "Noto Sans Shavian")
                  (set-fontset-font t 'osmanya "Noto Sans Osmanya")
                  (set-fontset-font t 'osage "Noto Sans Osage")
                  (set-fontset-font t 'elbasan "Noto Sans Elbasan")
                  (set-fontset-font t 'caucasian-albanian "Noto Sans CaucAlban")
                  (set-fontset-font t 'linear-a "Noto Sans Linear A")
                  (set-fontset-font t 'cypriot-syllabary "Noto Sans Cypriot")
                  (set-fontset-font t 'aramaic "Noto Sans ImpAramaic")
                  (set-fontset-font t 'palmyrene "Noto Sans Palmyrene")
                  (set-fontset-font t 'nabataean "Noto Sans Nabataean")
                  (set-fontset-font t 'hatran "Noto Sans Hatran")
                  (set-fontset-font t 'phoenician "Noto Sans Phoenician")
                  (set-fontset-font t 'lydian "Noto Sans Lydian")
                  (set-fontset-font t 'meroitic "Noto Sans Meroitic")
                  (set-fontset-font t 'kharoshthi "Noto Sans Kharoshthi")
                  (set-fontset-font t 'old-south-arabian "Noto Sans OldSouArab")
                  (set-fontset-font t 'old-north-arabian "Noto Sans OldNorArab")
                  (set-fontset-font t 'manichaean "Noto Sans Manichaean")
                  (set-fontset-font t 'avestan "Noto Sans Avestan")
                  (set-fontset-font t 'inscriptional-parthian "Noto Sans Inscriptional Parthian")
                  (set-fontset-font t 'inscriptional-pahlavi "Noto Sans Inscriptional Pahlavi")
                  (set-fontset-font t 'psalter-pahlavi "Noto Sans PsaPahlavi")
                  (set-fontset-font t 'old-turkic "Noto Sans Old Turkic")
                  (set-fontset-font t 'old-hungarian "Noto Sans OldHung")
                  (set-fontset-font t 'hanifi-rohingya "Noto Sans HanifiRohg")
                  (set-fontset-font t 'rumi-number "Noto Sans Symbols2")
                  (set-fontset-font t 'old-sogdian "Noto Sans OldSogdian")
                  (set-fontset-font t 'sogdian "Noto Sans Sogdian")
                  (set-fontset-font t 'elymaic "Noto Sans Elymaic")
                  (set-fontset-font t 'brahmi "Noto Sans Brahmi")
                  (set-fontset-font t 'kaithi "Noto Sans Kaithi")
                  (set-fontset-font t 'sora-sompeng "Noto Sans SoraSomp")
                  (set-fontset-font t 'chakma "Noto Sans Chakma")
                  (set-fontset-font t 'mahajani "Noto Sans Mahajani")
                  (set-fontset-font t 'sharada "Noto Sans Sharada")
                  (set-fontset-font t 'sinhala-archaic-number "Noto Sans Sinhala")
                  (set-fontset-font t 'khojki "Noto Sans Khojki")
                  (set-fontset-font t 'multani "Noto Sans Multani")
                  (set-fontset-font t 'khudawadi "Noto Sans Khudawadi")
                  (set-fontset-font t 'grantha "Noto Sans Grantha")
                  (set-fontset-font t 'newa "Noto Sans Newa")
                  (set-fontset-font t 'tirhuta "Noto Sans Tirhuta")
                  (set-fontset-font t 'siddham "Noto Sans Siddham")
                  (set-fontset-font t 'modi "Noto Sans Modi")
                  (set-fontset-font t 'takri "Noto Sans Takri")
                  (set-fontset-font t 'ahom "Noto Serif Ahom")
                  (set-fontset-font t 'dogra "Noto Serif Dogra")
                  (set-fontset-font t 'warang-citi "Noto Sans WarangCiti")
                  (set-fontset-font t 'zanabazar-square "Noto Sans Zanabazar")
                  (set-fontset-font t 'soyombo "Noto Sans Soyombo")
                  (set-fontset-font t 'pau-cin-hau "Noto Sans PauCinHau")
                  (set-fontset-font t 'bhaiksuki "Noto Sans Bhaiksuki")
                  (set-fontset-font t 'marchen "Noto Sans Marchen")
                  (set-fontset-font t 'masaram-gondi "Noto Sans Masaram Gondi")
                  (set-fontset-font t 'gunjala-gondi "Noto Sans Gunjala Gondi")
                  (set-fontset-font t 'cuneiform "Noto Sans Cuneiform")
                  (set-fontset-font t 'cuneiform-numbers-and-punctuation "Noto Sans Cuneiform")
                  (set-fontset-font t 'egyptian "Noto Sans EgyptHiero")
                  (set-fontset-font t 'anatolian "Noto Sans AnatoHiero")
                  (set-fontset-font t 'mro "Noto Sans Mro")
                  (set-fontset-font t 'bassa-vah "Noto Sans Bassa Vah")
                  (set-fontset-font t 'pahawh-hmong "Noto Sans Pahawh Hmong")
                  (set-fontset-font t 'miao "Noto Sans Miao")
                  (set-fontset-font t 'tangut "Noto Serif Tangut")
                  (set-fontset-font t 'tangut-components "Noto Serif Tangut")
                  (set-fontset-font t '(#x16fe0 . #x16fe0) "Noto Serif Tangut")
                  (set-fontset-font t 'duployan-shorthand "Noto Sans Duployan")
                  (set-fontset-font t 'byzantine-musical-symbol "Noto Music")
                  (set-fontset-font t 'musical-symbol "Noto Music")
                  (set-fontset-font t 'ancient-greek-musical-notation "Noto Music")
                  (set-fontset-font t 'mayan-numeral "Noto Sans Mayan Numerals")
                  (set-fontset-font t 'tai-xuan-jing-symbol "Noto Sans Symbols2")
                  (set-fontset-font t 'counting-rod-numeral "Noto Sans Symbols2")
                  (set-fontset-font t 'mathematical "Noto Sans Math")
                  (set-fontset-font t 'wancho "Noto Sans Wancho")
                  (set-fontset-font t 'mende-kikakui "Noto Sans Mende Kikakui")
                  (set-fontset-font t 'adlam "Noto Sans Adlam")
                  (set-fontset-font t 'indic-siyaq-number "Noto Sans Indic Siyaq Numbers")
                  (set-fontset-font t '(#x1ee00 . #x1eeff) "Noto Sans Math") ; arabic
                  (set-fontset-font t 'mahjong-tile "Noto Sans Symbols2")
                  (set-fontset-font t 'domino-tile "Noto Sans Symbols2")
                  (set-fontset-font t 'playing-cards "Noto Sans Symbols2")

                  ;; non Noto fonts
                  (set-fontset-font t 'kana "UniHentaiKana" nil 'append)
                  (set-fontset-font t 'latin "Iosevka" nil 'append)
                  (set-fontset-font t 'symbol "Iosevka" nil 'append)

                  ;; Nerd Font (defined thru -#xfd46)
                  (set-fontset-font t '( #xe000 .  #xf136) "Inconsolata Nerd Font"))))
#+end_src
*** font-lock-studio
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(font-lock-studio) "font-lock-studio" nil t)
#+END_SRC
** Color
*** ansi-color
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ansi-color-for-comint-mode-on) "ansi-color" nil t)

  (with-eval-after-load 'shell-mode
    ;; hooks
    (add-hook 'shell-mode-hook #'ansi-color-for-comint-mode-on))

  (with-eval-after-load 'compile
    ;; hooks
    (add-hook 'compilation-filter-hook
              #'(lambda ()
                  (ansi-color-apply-on-region (point-min) (point-max)))))
#+end_src
*** highlight-indent-guides
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(highlight-indent-guides-mode) "highlight-indent-guides" nil t)

  (with-eval-after-load 'yaml-mode
    ;; hooks
    (add-hook 'yaml-mode-hook 'highlight-indent-guides-mode))

  (with-eval-after-load 'highlight-indent-guides
    ;; config
    (setopt highlight-indent-guides-responsive 'stack)
    (setopt highlight-indent-guides-method 'bitmap))
#+end_src
*** hl-todo
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-hl-todo-mode) "hl-todo" nil t)

  (add-hook 'emacs-startup-hook #'global-hl-todo-mode)

  (with-eval-after-load 'hl-todo
    ;; config
    (setopt hl-todo-keyword-faces
            '(("HOLD" . "#d0bf8f")
              ("TODO" . "#cc9393")
              ("NOW" . "#dca3a3")
              ("SOMEDAY" . "#dc8cc3")
              ("WAIT" . "#7cb8bb")
              ("REVIEW" . "e60a39")
              ("QA" . "#88CF88")
              ("DONE" . "#afd8af")
              ("FIXME" . "#cc9393")
              ("MEMO" . "#coffee"))))
#+end_src
*** xterm-color
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(xterm-color-filter) "xterm-color" nil t)

  (add-hook 'emacs-startup-hook
            #'(lambda () (setenv "TERM" "xterm-256color")))

  (with-eval-after-load 'xterm-color
    ;; config
    (setopt xterm-color-preserve-properties t))
#+end_src
** Icon
*** emojify
#+begin_src emacs-lisp
  (autoload-if-found '(global-emojify-mode) "emojify" nil t)
#+end_src
*** nerd-icons-dired
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nerd-icons-dired-mode) "nerd-icons-dired" nil t)

  (with-eval-after-load 'dired-mode
    (add-hook 'dired-mode-hook #'nerd-icons-dired-mode))
#+end_src
*** nerd-icons-completion
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nerd-icons-completion-marginalia-setup) "nerd-icons-completion" nil t)

  (with-eval-after-load 'marginalia
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src
** Dashboard
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dashboard-refresh-buffer) "dashboard" nil t)

  (with-eval-after-load 'dashboard
    (setopt dashboard-startup-banner 'logo)
    (setopt dashboard-set-file-icons t)
    (setopt dashboard-startup-banner 4)
    (setopt dashboard-items '((recents . 10))))
#+end_src
** Dimmer
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(dimmer-mode) "dimmer" nil t)

  (add-hook 'emacs-startup-hook #'dimmer-mode)

  (with-eval-after-load 'dimmer
    ;; config
    (setopt dimmer-fraction 0.05))
#+end_src
** Doom
*** doom-themes
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook
            #'(lambda ()
                (when (require 'doom-themes)
                  (load-theme 'doom-dracula t))))

  (with-eval-after-load 'doom-themes
    ;; config
    (setopt doom-themes-padded-modeline t)
    (setopt doom-themes-enable-bold t)
    (setopt doom-themes-enable-italic t))
#+END_SRC
*** doom-modeline
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(doom-modeline-mode) "doom-modeline" nil t)

  (add-hook 'emacs-startup-hook #'doom-modeline-mode)
  (add-hook 'emacs-startup-hook #'(lambda () (line-number-mode 0)))
  (add-hook 'emacs-startup-hook #'(lambda () (column-number-mode 0)))

  (with-eval-after-load 'doom-modeline
    ;; config
    (setopt doom-modeline-buffer-file-name-style 'truncate-with-project)
    (setopt doom-modeline-icon `,(display-graphic-p))
    (setopt doom-modeline-major-mode-icon `,(display-graphic-p))
    (setopt doom-modeline-minor-modes nil)
    (setopt doom-modeline-check-icon nil))
#+END_SRC
** hl-line
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-hl-line-mode) "hl-line-mode" nil t)

  (add-hook 'emacs-startup-hook
            #'(lambda ()
                (when (not window-system)
                  (global-hl-line-mode))))

  (with-eval-after-load 'hl-line
    (set-face-attribute 'hl-line nil :inherit nil)
    (set-face-background 'hl-line "#444642"))
#+END_SRC
** idle-highlight-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(idle-highlight-mode) "idle-highlight-mode" nil t)

  (with-eval-after-load 'idle-highlight-mode
    (setopt idle-highlight-idle-time 0.1))

  (with-eval-after-load 'prog-mode
    (add-hook 'prog-mode-hook #'idle-highlight-mode))
#+end_src
** neotree
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(neotree-hide neotree-dir neotree-make-executor neo-open-file neo-open-dir) "neotree" nil t)

  (defun my/neotree-toggle ()
    (interactive)
    (let ((default-directory (or (locate-dominating-file default-directory ".neotree")
                                 (locate-dominating-file default-directory ".git"))))
      (if (and (fboundp 'neo-global--window-exists-p)
               (neo-global--window-exists-p))
          (neotree-hide)
        (neotree-dir default-directory))))

  (keymap-global-set "C-q" #'my/neotree-toggle)

  (with-eval-after-load 'neotree
    ;; config
    (setopt neo-theme 'ascii)
    (setopt neo-show-hidden-files t)

    ;; keybind
    (define-key neotree-mode-map (kbd "C-j")
                (neotree-make-executor
                 :file-fn #'neo-open-file
                 :dir-fn  #'neo-open-dir)))
#+END_SRC
** nyan-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nyan-mode) "nyan-mode" nil t)

  (add-hook 'emacs-startup-hook #'nyan-mode)

  (with-eval-after-load 'nyan-mode
    ;; config
    (setopt nyan-cat-face-number 5)
    (setopt nyan-animate-nyancat t))
#+END_SRC
** volatile-highlights
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(volatile-highlights-mode) "volatile-highlights" nil t)

  (add-hook 'emacs-startup-hook #'volatile-highlights-mode)
#+end_src
** topsy
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(topsy-mode) "topsy" nil t)

  (with-eval-after-load 'yaml-mode
    (add-hook 'yaml-mode-hook #'topsy-mode))
#+end_src
** idle-highlight-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(idle-highlight-mode) "idle-highlight-mode" nil t)

  (with-eval-after-load 'prog-mode
    (add-hook 'prog-mode-hook #'idle-highlight-mode))

  (with-eval-after-load 'idle-highlight-mode
    (setopt idle-highlight-idle-time 0.1))
#+end_src
** modus-themes
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '() "modus-themes" nil t)
#+end_src
* Awesome Package
** Joke
*** hacker-typer
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(hacker-typer) "hacker-typer" nil t)
#+end_src
*** power-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(power-mode) "power-mode" nil t)
#+end_src
*** sudden-death
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(sudden-death) "sudden-death" nil t)
#+end_src
*** redacted
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(redacted-mode) "redacted" nil t)

  (defun my/redacted-mode ()
    (interactive)
    (read-only-mode (if redacted-mode -1 1))
    (redacted-mode (if redacted-mode -1 1)))
#+end_src
*** lorem ipsum
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lorem-ipsum-insert-sentences
                       lorem-ipsum-insert-paragraphs
                       lorem-ipsum-insert-list) "lorem-ipsum" nil t)

  (keymap-global-set "C-c C-l s" #'lorem-ipsum-insert-sentences)
  (keymap-global-set "C-c C-l p" #'lorem-ipsum-insert-paragraphs)
  (keymap-global-set "C-c C-l l" #'lorem-ipsum-insert-list)
#+end_src
*** zalgo-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(zalgo-transform-word
                       zalgo-mode
                       zalgo-transform-region) "zalgo-mode" nil t)
#+end_src
** Password
*** pass
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(pass pass-view-mode) "pass" nil t)

  (add-to-list 'auto-mode-alist (cons (substitute-in-file-name "$HOME/ghq/github.com/takeokunn/private/password-store/.*\\.gpg") 'pass-view-mode))

  (with-eval-after-load 'pass
    (setopt pass-suppress-confirmations t))
#+end_src
*** password-generator
#+begin_src emacs-lisp
  (autoload-if-found '(password-generator-simple
                       password-generator-strong
                       password-generator-paranoid
                       password-generator-numeric
                       password-generator-phonetic
                       password-generator-custom) "password-generator" nil t)
#+end_src
*** sops
#+begin_src emacs-lisp
  (autoload-if-found '(sops-save-file
                       sops-cancel
                       sops-edit-file
                       global-sops-mode) "sops" nil t)

  (add-hook 'emacs-startup-hook #'global-sops-mode)
#+end_src
** Dictionary
*** define-word
#+begin_src emacs-lisp :tangle yes
  (defun my/define-word ()
    (interactive)
    (if (use-region-p)
        (call-interactively #'define-word-at-point)
      (call-interactively #'define-word)))

  (with-eval-after-load 'define-word
    (setopt define-word-displayfn-alist
            '((wordnik . takeokunn/define-word--display-in-buffer)
              (openthesaurus . takeokunn/define-word--display-in-buffer)
              (webster . takeokunn/define-word--display-in-buffer)
              (weblio . takeokunn/define-word--display-in-buffer))))
#+end_src
** GC
*** gcmh
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(gcmh-mode) "gcmh" nil t)

  (add-hook 'emacs-startup-hook #'gcmh-mode)

  (with-eval-after-load 'gcmh
    ;; config
    (setopt gcmh-verbose nil)

    ;; hooks
    (defvar my/gcmh-status nil)
    (advice-add #'garbage-collect
                :before
                (defun my/gcmh-log-start (&rest _)
                  (when gcmh-verbose
                    (setopt my/gcmh-status "Running GC..."))))

    (advice-add #'gcmh-message
                :override
                (defun my/gcmh-message (format-string &rest args)
                  (setopt my/gcmh-status
                        (apply #'format-message format-string args))
                  (run-with-timer 2 nil
                                  (lambda ()
                                    (setopt my/gcmh-status nil))))))
#+end_src
** Command
*** amx
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(amx-mode) "amx" nil t)

  (add-hook 'emacs-startup-hook #'amx-mode)

  (with-eval-after-load 'amx
    ;; config
    (setopt amx-history-length 100))
#+END_SRC
** GPG
*** epa-file
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(epa-file-enable) "epa-file" nil t)

  (add-hook 'emacs-startup-hook #'epa-file-enable)

  (with-eval-after-load 'epa-file
    ;; config
    (setopt epa-file-encrypt-to '("bararararatty@gmail.com"))
    (setopt epa-file-select-keys 'silent)
    (setopt epa-file-cache-passphrase-for-symmetric-encryption t)
    (setopt epg-pinentry-mode 'loopback)

    ;; fset
    (fset 'epg-wait-for-status 'ignore))
#+end_src
*** pinentry
https://github.com/ch11ng/exwm/wiki#gpg-pinentry

#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(pinentry-start) "pinentry" nil t)
#+end_src
** Help
*** helpful
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(helpful-callable
                       helpful-function
                       helpful-macro
                       helpful-command
                       helpful-key
                       helpful-variable
                       helpful-at-point) "helpful" nil t)

  (keymap-global-set "C-h f" #'helpful-callable)
  (keymap-global-set "C-h v" #'helpful-variable)
  (keymap-global-set "C-h k" #'helpful-key)
  (keymap-global-set "C-c C-d" #'helpful-at-point)
  (keymap-global-set "C-h F" #'helpful-function)
  (keymap-global-set "C-h C" #'helpful-command)
#+end_src
** Shell
*** exec-path-from-shell
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(exec-path-from-shell-initialize) "exec-path-from-shell")

  (add-hook 'emacs-startup-hook #'exec-path-from-shell-initialize)

  (with-eval-after-load 'exec-path-from-shell
    (setopt exec-path-from-shell-variables '("PATH" "TERM" "SSH_AUTH_SOCK" "COPILOT_LANGUAGE_SERVER_PATH")))
#+END_SRC
** Utility
*** htmlize
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'htmlize
    (setopt htmlize-html-charset 'utf-8))
#+end_src
*** midnight
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(midnight-mode) "midnight" nil t)

  (add-hook 'emacs-startup-hook #'midnight-mode)

  (with-eval-after-load 'midnight
    (setopt clean-buffer-list-delay-general 1))
#+end_src
*** lte
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lte-truncate-table-mode) "lte" nil t)

  (with-eval-after-load 'markdown-mode
    (add-hook 'markdown-mode-hook #'lte-truncate-table-mode))

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook #'lte-truncate-table-mode))
#+end_src
** Mouse
*** inhibit-mouse
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(inhibit-mouse-mode) "inhibit-mouse" nil t)

  (add-hook 'emacs-startup-hook #'inhibit-mouse-mode)
#+end_src
** PDF
*** pdf-tools
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(pdf-tools-install) "pdf-tools" nil t)
  (autoload-if-found '(pdf-occur-global-minor-mode) "pdf-occur" nil t)

  (add-hook 'emacs-startup-hook #'pdf-tools-install)
#+end_src
* Language Specific
** Basic Lisp
*** paredit
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(enable-paredit-mode
                       paredit-forward-slurp-sexp
                       paredit-splice-sexp
                       paredit-define-keys)
                     "paredit" nil t)

  (keymap-global-set "C-c f" #'paredit-forward-slurp-sexp)
  (keymap-global-set "M-s" #'paredit-splice-sexp)

  (with-eval-after-load 'paredit
    ;; hooks
    (add-hook 'paredit-mode-hook #'paredit-define-keys))

  (with-eval-after-load 'lisp-mode
    ;; hooks
    (add-hook 'lisp-mode-hook #'enable-paredit-mode)
    (add-hook 'lisp-data-mode-hook #'enable-paredit-mode))

  (with-eval-after-load 'emacs-lisp-mode
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'enable-paredit-mode))

  (with-eval-after-load 'clojure-mode
    ;; hooks
    (add-hook 'clojure-mode-hook #'enable-paredit-mode))

  (with-eval-after-load 'lisp-interaction-mode
    ;; hooks
    (add-hook 'lisp-interacton-mode-hook #'enable-paredit-mode))

  (with-eval-after-load 'scheme
    ;; hooks
    (add-hook 'scheme-mode-hook #'enable-paredit-mode))

  (with-eval-after-load 'simple
    ;; hooks
    (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode))

  (with-eval-after-load 'ielm
    ;; hooks
    (add-hook 'inferior-emacs-lisp-mode-hook #'enable-paredit-mode))
#+END_SRC
*** rainbow-delimiter
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(rainbow-delimiters-mode-enable) "rainbow-delimiters" nil t)

  (with-eval-after-load 'lisp-mode
    ;; hooks
    (add-hook 'lisp-mode-hook #'rainbow-delimiters-mode-enable))

  (with-eval-after-load 'emacs-lisp-mode
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode-enable))

  (with-eval-after-load 'clojure-mode
    ;; hooks
    (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode-enable))

  (with-eval-after-load 'scheme
    ;; hooks
    (add-hook 'scheme-mode-hook #'rainbow-delimiters-mode-enable))
#+END_SRC
** Common Lisp
*** slime
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'lisp-mode
    ;; hooks
    (add-hook 'lisp-mode-hook
              #'(lambda ()
                  (require 'slime)
                  (require 'slime-autoloads)

                  (defun my/slime-history ()
                    (interactive)
                    (if (and (fboundp '-distinct)
                             (fboundp 'f-read-text))
                        (insert
                         (completing-read
                          "choice history: "
                          (-distinct (read (f-read-text "~/.slime-history.eld"))))))))))

  (with-eval-after-load 'slime
    ;; config
    (setopt slime-net-coding-system 'utf-8-unix))

  (with-eval-after-load 'slime-repl
    ;; keybinds
    (define-key slime-repl-mode-map (kbd "C-c C-r") #'my/slime-history))
#+END_SRC
*** hyperspec
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(hyperspec-lookup) "hyperspec" nil t)

  (with-eval-after-load 'lisp-mode
    ;; keybinds
    (define-key lisp-mode-map (kbd "C-c h") #'hyperspec-lookup))
#+end_src
** Emacs Lisp
*** eros
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eros-mode) "eros" nil t)

  (with-eval-after-load 'emacs-lisp
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'eros-mode))
#+end_src
*** eldoc
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(turn-on-eldoc-mode) "eldoc" nil t)

  (with-eval-after-load 'elisp-mode
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook #'turn-on-eldoc-mode))

  (with-eval-after-load 'ielm
    ;; hooks
    (add-hook 'ielm-mode-hook #'turn-on-eldoc-mode))
#+end_src
*** elsa
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elsa-run) "elsa" nil t)
#+end_src
*** lispxmp
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lispxmp) "lispxmp" nil t)
#+end_src
*** macrostep
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(macrostep-expand macrostep-mode) "macrostep" nil t)

  (with-eval-after-load 'elisp-mode
    ;; keybinds
    (define-key emacs-lisp-mode-map (kbd "C-c e") #'macrostep-expand))
#+end_src
*** elisp-slime-nav
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elisp-slime-nav-mode) "elisp-slime-nav" nil t)

  (with-eval-after-load 'elisp-mode
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'elisp-slime-nav-mode))

  (with-eval-after-load 'ielm
    ;; hooks
    (add-hook 'ielm-mode-hook #'elisp-slime-nav-mode))
#+END_SRC
*** nameless
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nameless-mode) "nameless" nil t)

  (with-eval-after-load 'elisp-mode
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'nameless-mode))

  (with-eval-after-load 'ielm
    ;; hooks
    (add-hook 'ielm-mode-hook #'nameless-mode))
#+END_SRC
*** elisp-refs
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elisp-refs-function
                       elisp-refs-macro
                       elisp-refs-variable
                       elisp-refs-special
                       elisp-refs-symbol) "elisp-refs" nil t)
#+end_src
*** highlight-quoted
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(highlight-quoted-mode) "highlight-quoted" nil t)

  (with-eval-after-load 'elisp-mode
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'highlight-quoted-mode))
#+end_src
*** highlight-defined
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(highlight-defined-mode) "highlight-defined" nil t)

  (with-eval-after-load 'elisp-mode
    ;; hooks
    (add-hook 'emacs-lisp-mode-hook #'highlight-defined-mode))
#+end_src
*** my/ielm-history
#+begin_src emacs-lisp :tangle yes
  (defun my/ielm-history ()
    (interactive)
    (insert
     (completing-read
      "choice history: "
      (progn
        (let ((history nil)
              (comint-input-ring nil))
          (dotimes (index (ring-length comint-input-ring))
            (push (ring-ref comint-input-ring index) history))
          history)))))
#+END_SRC
** Clojure
*** anakondo
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(anakondo-minor-mode) "anakondo" nil t)

  ;; (with-eval-after-load 'clojure-mode
  ;;   (add-hook 'clojure-mode-hook #'anakondo-minor-mode)
  ;;   (add-hook 'clojurescript-mode-hook #'anakondo-minor-mode)
  ;;   (add-hook 'clojurec-mode-hook #'anakondo-minor-mode))
#+end_src
*** cider
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(cider cider-format-buffer cider-switch-to-last-clojure-buffer) "cider" nil t)
  (autoload-if-found '(cider-doc) "cider-doc" nil t)

  ;; (add-hook 'before-save-hook #'cider-format-buffer t t)

  (with-eval-after-load 'cider-common
    ;; config
    (setopt cider-special-mode-truncate-lines nil))

  (with-eval-after-load 'cider-mode
    ;; config
    (setopt cider-font-lock-reader-conditionals nil)
    (setopt cider-font-lock-dynamically '(macro core function var)))

  (with-eval-after-load 'cider-repl
    ;; config
    (setopt cider-repl-buffer-size-limit 1000000)
    (setopt cider-repl-wrap-history t)
    (setopt cider-repl-history-size 10000)
    (setopt cider-repl-tab-command #'indent-for-tab-command)
    (setopt cider-repl-display-in-current-window t))

  (with-eval-after-load 'nrepl-client
    ;; config
    (setopt nrepl-use-ssh-fallback-for-remote-hosts t)
    (setopt nrepl-hide-special-buffers t))

  (with-eval-after-load 'cider-eval
    ;; config
    (setopt cider-show-error-buffer nil)
    (setopt cider-auto-select-error-buffer nil))

  (with-eval-after-load 'clojure-mode
    ;; keybinds
    (define-key clojure-mode-map (kbd "C-c h") #'cider-doc))
#+END_SRC
*** kibit-helper
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(kibit kibit-current-file kibit-accept-proposed-change) "kibit-helper" nil t)
#+end_src
*** clj-refactor
#+begin_src emacs-lisp :tangle yes
  ;; (autoload-if-found '(clj-refactor-mode cljr-add-keybindings-with-prefix) "clj-refactor" nil t)

  ;; (add-hook 'clojure-mode-hook #'clj-refactor-mode)
  ;; (cljr-add-keybindings-with-prefix "C-c C-m")

  ;; (with-eval-after-load 'clj-refactor
  ;;   (setopt cljr-suppress-middleware-warnings t)
  ;;   (setopt cljr-hotload-dependencies t))
#+end_src
*** inf-clojure
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(inf-clojure) "inf-clojure" nil t)
#+end_src
** C/C++
*** clang-format
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(clang-format-buffer) "clang-format" nil t)
#+end_src
** Csv
*** rainbow-csv
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(rainbow-csv-mode) "rainbow-csv" nil t)

  (with-eval-after-load 'csv-mode
    (add-hook 'csv-mode-hook #'rainbow-csv-mode))
#+end_src
** JavaScript/TypeScript
*** nodejs-repl
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(nodejs-repl
                       nodejs-repl-send-last-expression
                       nodejs-repl-send-line
                       nodejs-repl-send-region
                       nodejs-repl-send-buffer
                       nodejs-repl-load-file
                       nodejs-repl-switch-to-repl) "nodejs-repl" nil t)

  (with-eval-after-load 'js2-mode
    ;; keyinds
    (define-key js2-mode-map (kbd "C-x C-e") #'nodejs-repl-send-last-expression)
    (define-key js2-mode-map (kbd "C-c C-j") #'nodejs-repl-send-line)
    (define-key js2-mode-map (kbd "C-c C-r") #'nodejs-repl-send-region)
    (define-key js2-mode-map (kbd "C-c C-c") #'nodejs-repl-send-buffer)
    (define-key js2-mode-map (kbd "C-c C-l") #'nodejs-repl-load-file)
    (define-key js2-mode-map (kbd "C-c C-z") #'nodejs-repl-switch-to-repl))
#+end_src
*** js2-refactor
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(js2-refactor-mode) "js2-refactor" nil t)

  (with-eval-after-load 'js2-refactor
    ;; config
    (setopt js2r-use-strict t))

  (with-eval-after-load 'js2-mode
    ;; hooks
    (add-hook 'js2-mode-hook #'js2-refactor-mode))

  (with-eval-after-load 'typescript-mode
    ;; hooks
    (add-hook 'typescript-mode-hook #'js2-refactor-mode))
#+END_SRC
*** jest
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(jest
                       jest-file
                       jest-file-dwim
                       jest-function
                       jest-last-failed
                       jest-repeat
                       jest-minor-mode) "jest" nil t)

  (with-eval-after-load 'typescript-mode
    ;; hooks
    (add-hook 'typescript-mode-hook #'jest-minor-mode)

    ;; config
    (setopt jest-executable "npx jest"))

  (with-eval-after-load 'typescript-mode
    (add-hook 'typescript-mode-hook
              #'(lambda ()
                  (projectile-register-project-type 'npx '("package.json" "yarn.lock")
                                                    :project-file "package.json"
                                                    :test "npx jest"
                                                    :test-suffix ".spec"))))
#+end_src
** Ruby
*** robe
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(robe-mode inf-ruby-console-auto) "robe" nil t)
#+end_src
*** rubocop
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(rubocop-mode) "rubocop" nil t)

  (with-eval-after-load 'ruby-mode
    ;; config
    (setopt rubocop-keymap-prefix "C-c C-x")

    ;; hooks
    (add-hook 'ruby-mode-hook #'rubocop-mode))
#+end_src
*** ruby-refactor
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ruby-refactor-mode-launch) "ruby-refactor" nil t)

  (with-eval-after-load 'ruby-mode
    ;; hooks
    (add-hook 'ruby-mode-hook #'ruby-refactor-mode-launch))
#+END_SRC
*** inf-ruby
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(inf-ruby inf-ruby-minor-mode) "inf-ruby" nil t)

  (defun my/irb-history ()
    (interactive)
    (when (and (fboundp '-distinct)
               (fboundp 's-lines)
               (fboundp 'f-read-text))
      (insert
       (completing-read
        "choose history: "
        (mapcar #'list (-distinct (s-lines (f-read-text "~/.irb_history"))))))))

  (with-eval-after-load 'ruby-mode
    ;; hooks
    (add-hook 'ruby-mode-hook #'inf-ruby-minor-mode))
#+END_SRC
*** yard-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(yard-mode) "yard-mode" nil t)

  (with-eval-after-load 'ruby-mode
    ;; hooks
    (add-hook 'ruby-mode-hook #'yard-mode))
#+end_src
** SQL
*** sql-indent
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(sqlind-setup sqlind-minor-mode) "sql-indent" nil t)

  (with-eval-after-load 'sql
    ;; hooks
    (add-hook 'sql-mode-hook #'sqlind-setup)
    (add-hook 'sql-mode-hook #'sqlind-minor-mode))
#+END_SRC
** PHP
*** composer
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(composer-get-config
                       composer-get-bin-dir
                       composer-install
                       composer-dump-autoload
                       composer-require
                       composer-update
                       composer-find-json-file
                       composer-view-lock-file
                       composer-run-vendor-bin-command
                       composer-run-script
                       composer-setup-managed-phar
                       composer) "composer" nil t)
#+end_src
*** php-runtime
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(php-runtime-expr php-runtime-eval) "php-runtime" nil t)
#+end_src
*** psysh
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(psysh psysh-doc) "psysh" nil t)

  (with-eval-after-load 'php-mode
    ;; keybinds
    (define-key php-mode-map (kbd "C-c h") #'psysh-doc))
#+end_src
*** laravel-tinker-repl
#+begin_src emacs-lisp :tangle yes
  ;; (autoload-if-found '(laravel-tinker-repl) "laravel-tinker-repl" nil t)

  ;; (with-eval-after-load 'php-mode
  ;;   (define-key php-mode-map (kbd "C-c C-c") #'laravel-tinker-repl-send-line)
  ;;   (define-key php-mode-map (kbd "C-c C-z") #'laravel-tinker-repl-switch-to-repl))
#+end_src
*** emacs-php-doc-block
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(php-doc-block) "php-doc-block" nil t)
#+end_src
*** phpstan
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(phpstan-analyze-file phpstan-analyze-this-file) "phpstan" nil t)

  (with-eval-after-load 'phpstan
    ;; config
    (setopt phpstan-memory-limit "4G"))
#+end_src
*** phpunit
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(phpunit-current-test
                       phpunit-current-class
                       phpunit-current-project
                       phpunit-group) "phpunit" nil t)

  (with-eval-after-load 'php-mode
    (keymap-set php-mode-map "C-c ;" #'phpunit-current-test))
#+end_src
** Markdown
*** poly-markdown
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(poly-markdown-mode) "poly-markdown" nil t)

  (add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode))
#+end_src
*** markdown-preview-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(markdown-preview-open-browser markdown-preview-mode) "markdown-preview-mode" nil t)

  (with-eval-after-load 'markdown-preview-mode
    ;; config
    (setopt markdown-preview-stylesheets (list "http://thomasf.github.io/solarized-css/solarized-light.min.css")))
#+end_src
** Fish
*** fish-repl
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(fish-repl) "fish-repl" nil t)
#+end_src
** Haskell
*** hindent
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(hindent-mode) "hindent" nil t)

  (with-eval-after-load 'haskell-mode
    ;; hooks
    (add-hook 'haskell-mode-hook #'hindent-mode))
#+end_src
** Web
*** emmet-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(emmet-mode) "emmet-mode" nil t)

  (with-eval-after-load 'html-mode
    ;; hooks
    (add-hook 'html-mode-hook #'emmet-mode))

  (with-eval-after-load 'web-mode
    ;; hooks
    (add-hook 'web-mode-hook #'emmet-mode))

  (with-eval-after-load 'css-mode
    ;; hooks
    (add-hook 'css-mode-hook #'emmet-mode))

  (with-eval-after-load 'nxml-mode
    ;; hooks
    (add-hook 'nxml-mode-hook #'emmet-mode))

  (with-eval-after-load 'web-php-blade-mode
    ;; hooks
    (add-hook 'web-php-blade-mode #'emmet-mode))

  (with-eval-after-load 'typescript-mode
    ;; hooks
    (add-hook 'typescript-tsx-mode-hook #'emmet-mode))

  (with-eval-after-load 'vue-mode
    ;; hooks
    (add-hook 'vue-mode-hook #'emmet-mode))

  (with-eval-after-load 'emmet-mode
    ;; keybinds
    (define-key emmet-mode-keymap (kbd "C-j") nil)
    (define-key emmet-mode-keymap (kbd "M-j") #'emmet-expand-line)

    ;; config
    (setopt emmet-self-closing-tag-style "")
    (setopt emmet-indent-after-insert nil))
#+END_SRC
** JSON
*** jq-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(jq-interactively) "jq-mode" nil t)

  (with-eval-after-load 'json-mode
    ;; keybinds
    (define-key json-mode-map (kbd "C-c C-j") #'jq-interactively))
#+end_src
*** json-reformat
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(json-reformat-region) "json-reformat" nil t)
#+end_src
** Python
*** py-isort
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(py-isort-region
                       py-isort-buffer
                       py-isort-before-save) "py-isort" nil t)
#+end_src
** Dart
*** flutter
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(flutter-test-mode
                       flutter-run
                       flutter-run-device
                       flutter-run-or-hot-reload
                       flutter-test-all
                       flutter-test-current-file
                       flutter-test-at-point
                       flutter-mode) "flutter" nil t)

  (with-eval-after-load 'flutter
    (add-hook 'flutter-mode-hook
              #'(lambda ()
                  (push '("*Flutter*") popwin:special-display-config)
                  (flutter--initialize))))

  (defun my/flutter-switch-buffer ()
    (interactive)
    (when (get-buffer "*Flutter*")
      (pop-to-buffer "*Flutter*")))

  (with-eval-after-load 'dart-mode
    (define-key dart-mode-map (kbd "C-c z") #'my/flutter-switch-buffer))
#+end_src
* Elfeed
** elfeed
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elfeed) "elfeed" nil t)

  (with-eval-after-load 'elfeed-show
    ;; config
    (setopt elfeed-show-entry-switch #'display-buffer))

  (with-eval-after-load 'elfeed-db
    ;; config
    (setopt elfeed-db-directory "~/.cache/elfeed"))

  (with-eval-after-load 'elfeed-search
    ;; config
    (setopt elfeed-search-filter "@2-week-ago"))

  (with-eval-after-load 'elfeed-curl
    ;; config
    (setopt elfeed-curl-max-connections 32))
#+end_src
** elfeed-org
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elfeed-org) "elfeed-org" nil t)

  (with-eval-after-load 'elfeed-search
    ;; hooks
    (add-hook 'elfeed-search-mode-hook #'elfeed-org))

  (with-eval-after-load 'elfeed-org
    ;; config
    (setopt rmh-elfeed-org-files '("~/.ghq/github.com/takeokunn/private/elfeed.org"))
    (setopt rmh-elfeed-org-auto-ignore-invalid-feeds t))
#+end_src
** elfeed-dashboard
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elfeed-dashboard) "elfeed-dashboard" nil t)

  (keymap-global-set "C-x w" #'elfeed-dashboard)

  (with-eval-after-load 'elfeed-dashboard
    ;; config
    (setopt elfeed-dashboard-file (locate-user-emacs-file "elfeed-dashboard.org")))
#+end_src
** elfeed-goodies
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(elfeed-goodies/setup) "elfeed-goodies" nil t)

  (with-eval-after-load 'elfeed-dashboard
    (add-hook 'elfeed-dashboard-mode-hook #'elfeed-goodies/setup))

  (with-eval-after-load 'elfeed-goodies
    (setopt elfeed-goodies/entry-pane-size 0.6))
#+end_src
* Eshell
** basic
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'esh-mode
    ;; keymap
    (define-key eshell-mode-map (kbd "C-h") #'delete-backward-char)
    (define-key eshell-mode-map (kbd "M-p") #'eshell-previous-matching-input-from-input))

  (with-eval-after-load 'em-cmpl
    (setopt eshell-cmpl-ignore-case t))

  (with-eval-after-load 'em-glob
    (setopt eshell-glob-include-dot-files t)
    (setopt eshell-glob-include-dot-dot nil)
    (setopt eshell-glob-show-progress t))

  (with-eval-after-load 'em-hist
    (setopt eshell-history-size 100000)
    (setopt eshell-hist-ignoredups t))

  (with-eval-after-load 'em-alias
    (setopt eshell-command-aliases-list '(("ll" "ls -la"))))

  (with-eval-after-load 'esh-cmd
    (setopt eshell-prefer-lisp-functions nil))

  (with-eval-after-load 'em-term
    (setopt eshell-destroy-buffer-when-process-dies t))
#+end_src
** functions
#+begin_src emacs-lisp :tangle yes
  (defun eshell/ff (&rest args)
    "Open a file in Emacs with ARGS, Some habits die hard."
    (if (null args)
        (bury-buffer)
      (mapc #'find-file (mapcar #'expand-file-name (eshell-flatten-list (reverse args))))))

  (defun eshell/unpack (file &rest args)
    "Unpack FILE with ARGS."
    (let ((command (some (lambda (x)
                           (if (string-match-p (car x) file)
                               (cadr x)))
                         '((".*\.tar.bz2" "tar xjf")
                           (".*\.tar.gz" "tar xzf")
                           (".*\.bz2" "bunzip2")
                           (".*\.rar" "unrar x")
                           (".*\.gz" "gunzip")
                           (".*\.tar" "tar xf")
                           (".*\.tbz2" "tar xjf")
                           (".*\.tgz" "tar xzf")
                           (".*\.zip" "unzip")
                           (".*\.Z" "uncompress")
                           (".*" "echo 'Could not unpack the file:'")))))
      (let ((unpack-command(concat command " " file " " (mapconcat 'identity args " "))))
        (eshell/printnl "Unpack command: " unpack-command)
        (eshell-command-result unpack-command))))

  (defun my/cat-with-syntax-highlight (filename)
    "Like cat(1) but with syntax highlighting."
    (let ((existing-buffer (get-file-buffer filename))
          (buffer (find-file-noselect filename)))
      (eshell-print
       (with-current-buffer buffer
         (if (fboundp 'font-lock-ensure)
             (font-lock-ensure)
           (with-no-warnings
             (font-lock-fontify-buffer)))
         (let ((contents (buffer-string)))
           (remove-text-properties 0 (length contents) '(read-only nil) contents)
           contents)))
      (unless existing-buffer
        (kill-buffer buffer))
      nil))

  (advice-add 'eshell/cat :override #'my/cat-with-syntax-highlight)
#+end_src
** prompt
#+begin_src emacs-lisp :tangle yes
  (defun my/eshell-prompt ()
    (concat (abbreviate-file-name (eshell/pwd))
            (if (= (user-uid) 0) " # " " $ ")))

  (with-eval-after-load 'em-prompt
    (setopt eshell-prompt-function #'my/eshell-prompt))
#+end_src
** eshell-fringe-status
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eshell-fringe-status-mode) "eshell-fringe-status" nil t)

  (with-eval-after-load 'esh-mode
    (add-hook 'eshell-mode-hook #'eshell-fringe-status-mode))
#+end_src
** esh-help
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(setup-esh-help-eldoc) "esh-help" nil t)

  (with-eval-after-load 'esh-mode
    (add-hook 'eshell-mode-hook #'setup-esh-help-eldoc))
#+end_src
** eshell-multiple
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eshell-multiple-new
                       eshell-multiple-next
                       eshell-multiple-prev
                       eshell-multiple-clear-buffer
                       eshell-multiple-switch-buffer
                       eshell-multiple-dedicated-toggle
                       eshell-multiple-dedicated-open
                       eshell-multiple-dedicated-close)
                     "eshell-multiple" nil t)

  (defalias 'eshell/new #'eshell-multiple-new)
  (defalias 'eshell/next #'eshell-multiple-next)
  (defalias 'eshell/prev #'eshell-multiple-prev)
  (defalias 'eshell/clear #'eshell-multiple-clear-buffer)

  (with-eval-after-load 'esh-mode
    (define-key eshell-mode-map (kbd "C-l") #'eshell-multiple-clear-buffer))
#+end_src
** eshell-z
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eshell-z) "eshell-z" nil t)

  (with-eval-after-load 'esh-mode
    (define-key eshell-mode-map (kbd "C-c C-q") #'eshell-z))
#+end_src
** eshell-did-you-mean
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eshell-did-you-mean-setup) "eshell-did-you-mean" nil t)

  (with-eval-after-load 'esh-mode
    (add-hook 'eshell-mode-hook #'eshell-did-you-mean-setup))
#+end_src
** eshell-syntax-highlight
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(eshell-syntax-highlighting-global-mode) "eshell-syntax-highlighting" nil t)

  (with-eval-after-load 'esh-mode
    (add-hook 'eshell-mode-hook #'eshell-syntax-highlighting-global-mode))
#+end_src
** emacs-fish-completion
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(global-fish-completion-mode) "fish-completion" nil t)

  (with-eval-after-load 'esh-mode
    (add-hook 'eshell-mode-hook #'global-fish-completion-mode))
#+end_src
* Org Mode
** Basic
*** org
#+begin_src emacs-lisp :tangle yes
  (keymap-global-set "C-c l" #'org-store-link)
  (keymap-global-set "C-c a" #'org-agenda)

  (with-eval-after-load 'org
    ;; keybind
    (define-key org-mode-map (kbd "C-c ,") #'org-insert-structure-template)
    (define-key org-mode-map (kbd "C-c C-,") #'org-insert-structure-template)

    ;; hooks
    (add-hook 'org-mode-hook #'view-mode)

    ;; directory
    (setq org-directory "~/.ghq/github.com/takeokunn/private")

    ;; todo
    (setq org-todo-keywords '((sequence "TODO(t)" "SOMEDAY(s)" "WAIT(w)" "REVIEW(r)" "QA(q)" "|" "DONE(d)")))

    ;; startup
    (setq org-startup-folded 'show3levels)
    (setq org-startup-truncated nil)

    (defvar my/org-agenda-files `(,(concat org-directory "/agenda")
                                  ,(concat org-directory "/archive/2023")
                                  ,(concat org-directory "/archive/2024")
                                  ,(concat org-directory "/archive/2025")))

    (setq org-agenda-files my/org-agenda-files)
    (setq org-archive-location `,(format (expand-file-name "archive/%s/%s.org::* Archived Tasks" org-directory)
                                         (format-time-string "%Y" (current-time))
                                         (format-time-string "%Y-%m-%d" (current-time))))

    ;; log
    (setq org-log-into-drawer t)
    (setq org-log-done 'time)

    (defun my/update-org-agenda-files ()
      (interactive)
      (setq org-agenda-files my/org-agenda-files)))
#+END_SRC
*** org-src
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org-src
    ;; config
    (setopt org-src-window-setup 'current-window)
    (setopt org-src-fontify-natively nil)
    (setopt org-src-tab-acts-natively nil)

    ;; hooks
    (add-hook 'org-src-mode-hook
              #'(lambda ()
                  (setq-local indent-tabs-mode nil)
                  (view-mode -1))))
#+END_SRC
*** org-clock
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-clock-load) "org-clock" nil t)

  (with-eval-after-load 'org
    ;; hooks
    (add-hook 'org-mode-hook #'org-clock-load))

  (with-eval-after-load 'org-clock
    ;; config
    (setq org-clock-out-remove-zero-time-clocks t)
    (setq org-clock-clocked-in-display 'mode-line))
#+end_src
*** org-list
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org-list
    (setq org-list-allow-alphabetical t))
#+end_src
*** org-keys
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org-keys
    ;; config
    (setq org-use-extra-keys t)
    (setq org-use-speed-commands t)

    ;; keybind
    (add-to-list 'org-speed-commands '("d" org-todo "DONE"))
    (add-to-list 'org-speed-commands '("j" call-interactively #'consult-org-heading)))
#+end_src
*** org-capture
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-capture) "org-capture" nil t)

  (keymap-global-set "C-c c" #'org-capture)

  (with-eval-after-load 'org-capture
    ;; advice
    (advice-add 'org-capture
                :before #'(lambda (&rest _)
                            (remove-hook 'org-mode-hook #'view-mode)
                            (remove-hook 'prog-mode-hook #'view-mode)))
    (advice-add 'org-capture
                :after #'(lambda (&rest _)
                           (add-hook 'org-mode-hook #'view-mode)
                           (add-hook 'prog-mode-hook #'view-mode)))

    ;; config
    (setq org-capture-use-agenda-date t)
    (setq org-capture-bookmark nil)
    (setq org-capture-templates `(("m" "Memo" entry (file ,(expand-file-name "memo.org" org-directory))
                                   "* %T\n%?")
                                  ("j" "Journal" entry (file+olp+datetree ,(expand-file-name "journal.org" org-directory))
                                   "* %U\n%?\n%i\n"))))
#+end_src
*** org-duration
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org-duration
    ;; config
    (setq org-duration-format (quote h:mm)))
#+end_src
*** org-id
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-id-store-link) "org-id" nil t)

  (with-eval-after-load 'org-id
    ;; config
    (setq org-id-locations-file (expand-file-name ".org-id-locations" org-directory))
    (setq org-id-extra-files (append org-agenda-text-search-extra-files)))
#+end_src
*** org-crypt
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-encrypt-entry
                       org-encrypt-entries
                       org-decrypt-entry
                       org-decrypt-entries) "org-crypt" nil t)

  (with-eval-after-load 'org
    ;; config
    (setopt org-tags-exclude-from-inheritance '("crypt")))

  (with-eval-after-load 'org-crypt
    ;; config
    (setopt org-crypt-key "0B10DAA7BA0236D7382287660F79C0AB03FD7A1C"))
#+end_src
*** org-table
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(orgtbl-mode org-table-begin org-table-end) "org-table" nil t)

  (with-eval-after-load 'org-table
    (defun my/org-table-align-markdown ()
      "Replace \"+\" sign with \"|\" in org-table."
      (when (member major-mode '(markdown-mode))
        (save-excursion
          (save-restriction
            (narrow-to-region (org-table-begin) (org-table-end))
            (goto-char (point-min))
            (while (search-forward "-+-" nil t)
              (replace-match "-|-"))))))

    (advice-add 'org-table-align :before #'my/org-table-align-markdown))
#+end_src
*** org-journal
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org-journal
    ;; config
    (setq org-journal-dir (expand-file-name "journal" org-directory))
    (setq org-journal-start-on-weekday 7)
    (setq org-journal-prefix-key "C-c j"))
#+end_src
*** org-generate
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-generate) "org-generate" nil t)
#+end_src
*** org-pomodoro
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-pomodoro) "org-pomodoro" nil t)
#+end_src
*** org-view-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-view-mode) "org-view-mode" nil t)
#+end_src
*** org-random-todo
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-random-todo org-random-todo-goto-current) "org-random-todo" nil t)
#+end_src
*** org-dashboard
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-dashboard-display) "org-dashboard" nil t)
#+end_src
*** org-volume
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-volume-update-entry-from-dblock) "org-volume" nil t)
#+end_src
*** org-sliced-images
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-sliced-images-mode) "org-sliced-images" nil t)

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook #'org-sliced-images-mode))
#+end_src
*** org-ql
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-ql-query org-ql-select) "org-ql" nil t)
#+end_src
** Theme
*** org-faces
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org-faces
    ;; config
    (setq org-link '(t (:foreground "#ebe087" :underline t))))
#+end_src
*** org-superstar
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-superstar-mode) "org-superstar")

  (with-eval-after-load 'org
    ;; hooks
    (add-hook 'org-mode-hook #'org-superstar-mode))

  (with-eval-after-load 'org-superstar
    ;; config
    (setopt org-superstar-headline-bullets-list '("◉" "○" "✸" "✿"))
    (setopt org-superstar-leading-bullet " "))
#+end_src
** Content
*** toc-org
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(toc-org-mode) "toc-org" nil t)

  (with-eval-after-load 'org
    ;; hooks
    (add-hook 'org-mode-hook #'toc-org-mode))
#+end_src
** Presentation
*** org-tree-slide
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-tree-slide-mode org-tree-slide-skip-done-toggle) "org-tree-slide" nil t)

  (with-eval-after-load 'org-tree-slide
    ;; config
    (setopt org-tree-slide-skip-outline-level 4))
#+end_src
** Org Link
*** org-link
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-store-link) "ol" nil t)

  (with-eval-after-load 'ol
    ;; config
    (setq org-link-file-path-type 'relative))
#+end_src
*** orgit
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(orgit-store-link

                       ;; orgit
                       orgit-status-store
                       orgit-status-open
                       orgit-status-export
                       orgit-status-complete-link

                       ;; orgit-log
                       orgit-log-store
                       orgit-log-open
                       orgit-log-export
                       orgit-log-complete-link

                       ;; orgit-rev
                       orgit-rev-store
                       orgit-rev-open
                       orgit-rev-export
                       orgit-rev-complete-link) "orgit" nil t)

  (with-eval-after-load 'org
    (org-link-set-parameters "orgit"
                             :store    #'orgit-status-store
                             :follow   #'orgit-status-open
                             :export   #'orgit-status-export
                             :complete #'orgit-status-complete-link)

    (org-link-set-parameters "orgit-log"
                             :store    #'orgit-log-store
                             :follow   #'orgit-log-open
                             :export   #'orgit-log-export
                             :complete #'orgit-log-complete-link)

    (org-link-set-parameters "orgit-rev"
                             :store    #'orgit-rev-store
                             :follow   #'orgit-rev-open
                             :export   #'orgit-rev-export
                             :complete #'orgit-rev-complete-link))

  (with-eval-after-load 'magit
    (keymap-set magit-mode-map "<remap> <org-store-link>" #'orgit-store-link))
#+end_src
** Org Agenda
*** Basic
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-agenda) "org-agenda" nil t)

  (with-eval-after-load 'org-agenda
    ;; config
    (setq org-agenda-span 'day)
    (setq org-agenda-start-on-weekday 1)
    (setq org-agenda-todo-ignore-with-date t)

    ;; advices
    (advice-add 'org-archive-subtree :around #'my/advice-disable-buffer-readonly))
#+end_src
*** org-super-agenda
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-super-agenda-mode) "org-super-agenda" nil t)

  (add-hook 'emacs-startup-hook #'org-super-agenda-mode)

  (with-eval-after-load 'org-super-agenda
    ;; config
    (setopt org-super-agenda-groups '((:log t)
                                      (:auto-group t)
                                      (:name "Today List..." :scheduled today)
                                      (:name "Due Today List..." :deadline today)
                                      (:name "Overdue List..." :deadline past)
                                      (:name "Due Soon List" :deadline future)
                                      (:name "TODO List..." :todo "TODO")
                                      (:name "WAIT List..." :todo "WAIT")
                                      (:name "DONE List..." :todo "DONE")
                                      (:name "SOMEDAY List..." :todo "SOMEDAY")
                                      (:discard (:anything t)))))
#+end_src
*** org-hyperscheduler
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-hyperscheduler-open) "org-hyperscheduler" nil t)
#+end_src
** Org External Tools
*** org-redmine
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-redmine-get-issue) "org-redmine" nil t)

  (with-eval-after-load 'org-redmine
    ;; config
    (setopt org-redmine-template-header "[#%i%] %s%")
    (setopt org-redmine-template-property '(("project_name" . "%p_n%"))))
#+end_src
*** org-ai
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-ai-mode) "org-ai" nil t)

  (with-eval-after-load 'org
    ;; config
    (add-to-list 'org-structure-template-alist '("A" . "ai"))

    ;; hooks
    (add-hook 'org-mode-hook #'org-ai-mode))

  (with-eval-after-load 'org-ai
    ;; config
    (setopt org-ai-default-chat-model "gpt-3.5-turbo"))
#+end_src
** Org Babel
*** basic
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-do-load-languages) "org" nil t)

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook
              #'(lambda ()
                  (org-babel-do-load-languages 'org-babel-load-languages
                                               '((awk . t)
                                                 (C . t)
                                                 (R . t)
                                                 (clojure . t)
                                                 (emacs-lisp . t)
                                                 (haskell . t)
                                                 (java . t)
                                                 (js . t)
                                                 (lisp . t)
                                                 (makefile . t)
                                                 (perl . t)
                                                 (plantuml . t)
                                                 (python . t)
                                                 (ruby . t)
                                                 (scheme . t)
                                                 (shell . t)
                                                 (sql . t)
                                                 (shell . t))))))

  (with-eval-after-load 'ob-core
    ;; config
    (setq org-confirm-babel-evaluate nil)
    (setq org-babel-default-header-args '((:session . "none")
                                          (:results . "drawer replace")
                                          (:exports . "code")
                                          (:cache . "no")
                                          (:noweb . "no")
                                          (:hlines . "no")
                                          (:tangle . "no"))))

  (with-eval-after-load 'ob-eval
    ;; advice
    (advice-add #'org-babel-eval-error-notify
                :around #'(lambda (old-func &rest args)
                            (when (not (string= (nth 1 args)
                                                "mysql: [Warning] Using a password on the command line interface can be insecure.\n"))
                              (apply old-func args)))))

  (with-eval-after-load 'ob-tangle
    ;; advice
    (advice-add 'org-babel-tangle :before #'org-decrypt-entries)
    (advice-add 'org-babel-tangle :after #'org-encrypt-entries)
    (advice-add 'org-babel-tangle :around #'my/advice-disable-buffer-readonly))
#+end_src
*** ob-async
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ob-async-org-babel-execute-src-block) "ob-async" nil t)
#+end_src
*** ob-fish
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:fish) "ob-fish" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("fish" . fish)))
#+end_src
*** ob-rust
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:rust) "ob-rust" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("rust" . rust)))
#+end_src
*** ob-go
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:go) "ob-go" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("go" . go)))
#+end_src
*** ob-translate
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ob-translate:google-translate) "ob-translate" nil t)

  (with-eval-after-load 'text-mode
    (define-derived-mode translate-mode text-mode "translate"))

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("translate" . translate)))
#+end_src
*** ob-typescript
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:typescript) "ob-typescript" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("typescript" . typescript)))
#+end_src
*** ob-php
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:php) "ob-php" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("php" . php)))
#+end_src
*** ob-phpstan
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:phpstan) "ob-phpstan" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("phpstan" . phpstan)))
#+end_src
*** ob-http
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:http) "ob-http" nil t)
  (autoload-if-found '(ob-http-mode) "ob-http-mode" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("http" . ob-http)))
#+end_src
*** ob-mermaid
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:mermaid) "ob-mermaid" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("mermaid" . mermaid)))
#+end_src
*** ob-graphql
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:graphql) "ob-graphql" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("graphql" . graphql)))
#+end_src
*** ob-rust
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:rust) "ob-rust" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("rust" . rust)))
#+end_src
*** ob-swift
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:swift) "ob-swift" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("swift" . swift)))
#+end_src
*** ob-elixir
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:elixir) "ob-elixir" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("elixir" . elixir)))
#+end_src
*** ob-dart
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:dart) "ob-dart" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("dart" . dart)))
#+end_src
*** ob-fsharp
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:fsharp) "ob-fsharp" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("fsharp" . fsharp)))
#+end_src
*** ob-treesitter
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:treesitter) "ob-treesitter" nil t)

  (with-eval-after-load 'prog-mode
    (define-derived-mode treesitter-mode prog-mode "treesitter"))

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("treesitter" . treesitter)))
#+end_src
*** ob-base64
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:base64) "ob-base64" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("base64" . base64)))
#+end_src
*** ob-lisp
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'ob-lisp
    (defalias 'org-babel-execute:common-lisp 'org-babel-execute:lisp))
#+end_src
*** ob-racket
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:racket) "ob-racket" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("racket" . racket)))
#+end_src
*** ob-prolog
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-babel-execute:prolog) "ob-prolog" nil t)

  (with-eval-after-load 'org-src
    (add-to-list 'org-src-lang-modes '("prolog" . pl)))
#+end_src
*** org-nix-shell
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-nix-shell-mode) "org-nix-shell" nil t)

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook #'org-nix-shell-mode))
#+end_src
** Org Publish
*** ox
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-export-define-backend) "ox" nil t)
#+end_src
*** ox-html
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'ox-html
    ;; config
    (setopt org-html-head-include-default-style nil)
    (setopt org-html-head-include-scripts nil)
    (setopt org-html-doctype "html5")
    (setopt org-html-coding-system 'utf-8-unix))
#+end_src
*** ox-gfm
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-gfm-export-as-markdown
                       org-gfm-convert-region-to-md
                       org-gfm-export-to-markdown
                       org-gfm-publish-to-gfm) "ox-gfm" nil t)
#+end_src
*** ox-zenn
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-zenn-export-as-markdown
                       org-zenn-export-to-markdown
                       org-zenn-publish-to-markdown
                       org-zenn-convert-region-to-md) "ox-zenn" nil t)
#+end_src
*** ox-hatena
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-hatena-export-as-hatena
                       org-hatena-export-to-hatena
                       org-hatena-export-to-hatena-and-open) "ox-hatena" nil t)
#+end_src
*** ox-qmd
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-qmd-export-as-markdown
                       org-qmd-convert-region-to-md
                       org-qmd-export-to-markdown) "ox-qmd" nil t)
#+end_src
*** ox-hugo
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-hugo-export-as-md
                       org-hugo-export-to-md
                       org-hugo-export-wim-to-md
                       org-hugo-debug-info) "ox-hugo" nil t)

  (with-eval-after-load 'ox-hugo
    ;; config
    (setopt org-hugo-auto-set-lastmod t))
#+end_src
*** ox-typst
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-typst-export-block
                       org-typst-headline
                       org-typst-item
                       org-typst-keyword
                       org-typst-section
                       org-typst-src-block
                       org-typst-export-as-typst
                       org-typst-export-to-typst
                       org-typst-export-to-pdf
                       org-typst-compile) "ox-typst" nil t)

  (org-export-define-backend 'typst-slide
    '((export-block . org-typst-export-block)
      (headline . org-typst-headline)
      (item . org-typst-item)
      (keyword . org-typst-keyword)
      (section . org-typst-section)
      (src-block . org-typst-src-block))
    :menu-entry
    '(?y "Export to Typst"
         ((?F "As Typst buffer" org-typst-export-as-typst)
          (?f "As Typst file" org-typst-export-to-typst)
          (?p "As PDF file" org-typst-export-to-pdf)))
    :options-alist
    '((:typst-format-drawer-function nil nil #'(lambda (_ contents) contents))
      (:typst-format-inlinetask-function nil
                                         nil
                                         #'(lambda (_ contents) contents))))

  (defun org-typst-slide-export-as-typst
      (&optional async subtreep visible-only body-only ext-plist)
    (interactive)
    (org-export-to-buffer 'typst-slide "*Org Typst Slide Export*"
      async subtreep visible-only body-only ext-plist))

  (defun org-typst-slide-export-to-typst
      (&optional async subtreep visible-only body-only ext-plist)
    (interactive)
    (let ((outfile (org-export-output-file-name ".typ" subtreep)))
      (org-export-to-file 'typst-slide outfile
        async subtreep visible-only body-only ext-plist)))
#+end_src
** Org Roam
*** basic
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-graph) "org-roam" nil t)

  (keymap-global-set "C-c n g" #'org-roam-graph)
  (keymap-global-set "C-c n l" #'org-roam-buffer-toggle)
  (keymap-global-set "C-c n f" #'org-roam-node-find)
  (keymap-global-set "C-c n i" #'org-roam-node-insert)
  (keymap-global-set "C-c n c" #'org-roam-capture)
  (keymap-global-set "C-c n d" #'org-roam-dailies-map)
  (keymap-global-set "C-c n j" #'org-roam-dailies-goto-today)

  (with-eval-after-load 'org-roam
    ;; config
    (setopt org-roam-directory `,(concat (s-trim-right (shell-command-to-string "ghq root"))
                                         "/github.com/takeokunn/blog")))
#+end_src
*** org-roam-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-buffer-toggle) "org-roam-mode" nil t)
#+end_src
*** org-roam-node
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-node-find org-roam-node-insert) "org-roam-node" nil t)

  (with-eval-after-load 'org-roam-node
    (setopt org-roam-completion-everywhere nil))
#+end_src
*** org-roam-db
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-db-autosync-enable) "org-roam-db" nil t)

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook #'org-roam-db-autosync-enable))

  (with-eval-after-load 'org-roam-db
    ;; config
    (setq org-roam-db-gc-threshold (* 4 gc-cons-threshold)))
#+end_src
*** org-roam-capture
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-capture) "org-roam-capture" nil t)

  (with-eval-after-load 'org-roam-capture
    ;; config
    (setopt org-roam-capture-templates '(("f" "Fleeting(一時メモ)" plain "%?"
                                          :target (file+head "org/fleeting/%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n")
                                          :unnarrowed t)
                                         ("l" "Literature(文献)" plain "%?"
                                          :target (file+head "org/literature/%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n")
                                          :unnarrowed t)
                                         ("p" "Permanent(記事)" plain "%?"
                                          :target (file+head "org/permanent/%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n")
                                          :unnarrowed t)
                                         ("d" "Diary(日記)" plain "%?"
                                          :target (file+head "org/diary/%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n")
                                          :unnarrowed t)
                                         ("z" "Zenn" plain "%?"
                                          :target (file+head "org/zenn/articles/%<%Y%m%d%H%M%S>.org" "#+TITLE: ${title}\n")
                                          :unnarrowed t)
                                         ("m" "Private" plain "%?"
                                          :target (file+head "org/private/%<%Y%m%d%H%M%S>.org.gpg" "#+TITLE: ${title}\n")
                                          :unnarrowed t)
                                         ("o" "Poem" plain "%?"
                                          :target (file+head "org/poem/%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n")
                                          :unnarrowed t))))
#+end_src
*** org-roam-dailies
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-dailies-map
                       org-roam-dailies-goto-today
                       org-roam-dailies-goto-yesterday
                       org-roam-dailies-goto-tomorrow
                       org-roam-dailies-capture-today
                       org-roam-dailies-goto-next-note
                       org-roam-dailies-goto-previous-note
                       org-roam-dailies-goto-date
                       org-roam-dailies-capture-date
                       org-roam-dailies-find-directory) "org-roam-dailies" nil t)

  (with-eval-after-load 'org-roam-dailies
    ;; config
    (setopt org-roam-dailies-directory "org/daily/")

    ;; keybind
    (define-key org-roam-dailies-map (kbd "d") #'org-roam-dailies-goto-today)
    (define-key org-roam-dailies-map (kbd "y") #'org-roam-dailies-goto-yesterday)
    (define-key org-roam-dailies-map (kbd "t") #'org-roam-dailies-goto-tomorrow)
    (define-key org-roam-dailies-map (kbd "n") #'org-roam-dailies-capture-today)
    (define-key org-roam-dailies-map (kbd "f") #'org-roam-dailies-goto-next-note)
    (define-key org-roam-dailies-map (kbd "b") #'org-roam-dailies-goto-previous-note)
    (define-key org-roam-dailies-map (kbd "c") #'org-roam-dailies-goto-date)
    (define-key org-roam-dailies-map (kbd "v") #'org-roam-dailies-capture-date)
    (define-key org-roam-dailies-map (kbd ".") #'org-roam-dailies-find-directory))
#+end_src
*** org-roam-export
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-export--org-html--reference) "org-roam-export" nil t)

  (with-eval-after-load 'ox-html
    (advice-add 'org-html--reference :override #'org-roam-export--org-html--reference))
#+end_src
*** org-roam-graph
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-graph org-roam-graph--open) "org-roam-graph" nil t)
#+end_src
*** org-roam-overlay
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-overlay-mode) "org-roam-overlay" nil t)

  (with-eval-after-load 'org-roam-mode
    (add-hook 'org-roam-mode-hook #'org-roam-overlay-mode))
#+end_src
*** org-roam-protocol
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-protocol-open-ref org-roam-protocol-open-node) "org-roam-protocol" nil t)

  (with-eval-after-load 'org-roam-protocol
    ;; alist
    (add-to-list 'org-protocol-protocol-alist '("org-roam-ref" :protocol "roam-ref" :function org-roam-protocol-open-ref))
    (add-to-list 'org-protocol-protocol-alist '("org-roam-node" :protocol "roam-node" :function org-roam-protocol-open-node))

    ;; config
    (setopt org-roam-protocol-store-links t))
#+end_src
*** consult-org-roam
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(consult-org-roam-mode
                       consult-org-roam-file-find
                       consult-org-roam-backlinks
                       consult-org-roam-backlinks-recursive
                       consult-org-roam-forward-links
                       consult-org-roam-search) "consult-org-roam" nil t)

  (keymap-global-set "C-c n f" #'consult-org-roam-file-find)
  (keymap-global-set "C-c n b" #'consult-org-roam-backlinks)
  (keymap-global-set "C-c n B" #'consult-org-roam-backlinks-recursive)
  (keymap-global-set "C-c n l" #'consult-org-roam-forward-links)
  (keymap-global-set "C-c n r" #'consult-org-roam-search)

  (with-eval-after-load 'org
    ;; hooks
    (add-hook 'org-mode-hook #'consult-org-roam-mode))

  (with-eval-after-load 'consult-org-roam
    ;; config
    (setq consult-org-roam-grep-func #'consult-ripgrep)
    (setq consult-org-roam-buffer-narrow-key ?r)
    (setq consult-org-roam-buffer-after-buffers t))
#+end_src
*** org-roam-ui
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-ui-mode) "org-roam-ui" nil t)

  (with-eval-after-load 'org-roam-mode
    ;; hooks
    (add-hook 'org-roam-mode-hook #'org-roam-ui-mode))

  (with-eval-after-load 'org-roam-ui
    ;; config
    (setopt org-roam-ui-sync-theme t)
    (setopt org-roam-ui-follow t)
    (setopt org-roam-ui-update-on-save t)
    (setopt org-roam-ui-open-on-start t))
#+end_src
*** org-roam-timestamps
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-timestamps-mode) "org-roam-timestamps" nil t)

  (with-eval-after-load 'org-roam-mode
    ;; hooks
    (add-hook 'org-roam-mode #'org-roam-timestamps-mode))

  (with-eval-after-load 'org-roam-timestamps
    ;; config
    (setopt org-roam-timestamps-remember-timestamps nil))
#+end_src
*** org-roam-ql
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-ql-nodes
                       org-roam-ql-search
                       org-roam-ql-defpred
                       org-roam-ql-agenda-buffer-from-roam-buffer
                       org-roam-ql-refresh-buffer
                       org-dblock-write:org-roam-ql) "org-roam-ql" nil t)
#+end_src
*** org-roam-ql-ql
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-roam-ql-ql-init) "org-roam-ql-ql" nil t)

  (add-hook 'emacs-startup-hook #'org-roam-ql-ql-init)
#+end_src
* EXWM
** exwm
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(exwm-input-set-key) "exwm-input" nil t)
#+end_src
** exwm-edit
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(exwm-edit--compose-minibuffer) "exwm-edit" nil t)

  ;; (exwm-input-set-key (kbd "C-c '") #'exwm-edit--compose-minibuffer)
  ;; (exwm-input-set-key (kbd "C-c C-'") #'exwm-edit--compose-minibuffer)

  (with-eval-after-load 'exwm-edit
    (setq exwm-edit-bind-default-keys nil))
#+end_src
** exwm-modeline
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(exwm-modeline-mode) "exwm-modeline")

  (with-eval-after-load 'exwm-core
    (add-hook 'exwm-mode-hook #'exwm-modeline-mode))

  (with-eval-after-load 'exwm-modeline
    (setopt exwm-modeline-short t))
#+end_src
* AI
** copilot.el
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(copilot-login copilot-mode) "copilot" nil t)

  (keymap-global-set "C-x C-:" #'copilot-mode)

  (with-eval-after-load 'copilot
    ;; config
    (setopt copilot-log-max 100000)
    (setopt copilot-server-executable (getenv "COPILOT_LANGUAGE_SERVER_PATH"))

    ;; keymap
    (define-key copilot-mode-map (kbd "C-S-i") #'copilot-complete)
    (define-key copilot-mode-map (kbd "C-S-a") #'copilot-accept-completion)
    (define-key copilot-mode-map (kbd "C-c # a") #'copilot-accept-completion))
#+end_src
** copilot-chat.el
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(copilot-chat-transient-code copilot-chat-insert-commit-message) "copilot-chat" nil t)

  (with-eval-after-load 'git-commit
    (add-hook 'git-commit-setup-hook #'copilot-chat-insert-commit-message))

  (with-eval-after-load 'copilot-chat-common
    ;; config
    (setopt copilot-chat-model "claude-3.7-sonnet")
    (setopt copilot-chat-frontend 'shell-maker))

  (with-eval-after-load 'copilot-chat-prompts
    (let ((my/copilot-chat-prompt "日本語で解答してください。\nあなたは一流のコーディングチューターです。コードの説明は、高レベルな概念と詳細な内容のバランスが完璧です。あなたのアプローチにより、学習者はコードの書き方だけでなく、効果的なプログラミングを導く基本原理も理解できます。\n名前を尋ねられた場合、必ず「GitHub Copilot」と答えてください。\nユーザーの要件を正確かつ厳密に守ってください。\n専門知識はソフトウェア開発トピックに厳密に限定されています。\nMicrosoft のコンテンツポリシーに従ってください。\n著作権を侵害する内容は避けてください。\nソフトウェア開発に関連しない質問には、AIプログラミングアシスタントであることを簡単に伝えるだけにしてください。\n回答は簡潔かつ非個人的なものにしてください。\nMarkdown形式を使用して回答してください。\nコードブロックの最初にプログラミング言語名を必ず記述してください。\n全体を三重バッククオートで囲まないようにしてください。\nユーザーは Neovim という IDE を使用しています。この IDE には、開いているファイルのエディタ、統合ユニットテストサポート、コード実行結果を表示する出力ペイン、統合ターミナルがあります。\nアクティブなドキュメントは、ユーザーが現在見ているソースコードです。\n1 回の会話で 1 つの回答しかできません。\n\n追加ルール\nステップごとに考えてください：\n1. 提供されたコード選択部分やユーザーの質問、関連するエラー、プロジェクトの詳細、クラス定義などを確認します。\n2. コードや概念、ユーザーの質問が不明確な場合は、明確化する質問を行います。\n3. ユーザーが特定の質問やエラーを提供している場合は、選択されたコードと追加のコンテキストに基づいて答えてください。それ以外の場合は、選択されたコードの説明に集中します。\n4. コードの可読性やパフォーマンス向上の機会があれば、提案を行ってください。\n\n簡潔でわかりやすく、かつ徹底的な説明を心がけ、広範な予備知識があると仮定しないでください。\n開発者に親しみやすい用語やアナロジーを使用してください。\n注意すべき点や、初心者が見落としがちな部分を指摘してください。\n提供されたコンテキストに沿った具体的で関連性の高い例を示してください。\n"))
      (setopt copilot-chat-markdown-prompt my/copilot-chat-prompt)
      (setopt copilot-chat-org-prompt my/copilot-chat-prompt)))

  (with-eval-after-load 'copilot-chat-copilot
    (setopt copilot-chat-prompt-review "次のコードをレビューしてください。\n"))
#+end_src
** llm
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(make-llm-ollama) "llm-ollama" nil t)

  (with-eval-after-load 'llm
    ;; config
    (setopt llm-warn-on-nonfree nil))
#+end_src
** ellama
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ellama-transient-main-menu) "ellama" nil t)
  (autoload-if-found '(ellama-community-prompts-select-blueprint) "ellama-community-prompts")

  (keymap-global-set "C-c e" #'ellama-transient-main-menu)

  (with-eval-after-load 'ellama
    ;; config
    (setopt ellama-language "日本語")

    (let ((gemma2 (make-llm-ollama :chat-model "gemma2:9b" :embedding-model "gemma2:9b"))
          (codellama (make-llm-ollama :chat-model "codellama:latest" :embedding-model "codellama:latest"))
          (deepseek (make-llm-ollama :chat-model "deepseek-r1:8b" :embedding-model "deepseek-r1:8b")))
      (setopt ellama-provider gemma2)
      (setopt ellama-translation-provider gemma2)
      (setopt ellama-summarization-provider deepseek)
      (setopt ellama-coding-provider codellama)
      (setopt ellama-providers
              `(("gemma2" . ,gemma2)
                ("codellama" . ,codellama)
                ("deepseek" . ,deepseek))))

    ;; advice
    (advice-add 'ellama-instant
                :before #'(lambda (&rest _)
                            (remove-hook 'org-mode-hook #'view-mode)))
    (advice-add 'ellama-instant
                :after #'(lambda (&rest _)
                           (add-hook 'org-mode-hook #'view-mode))))
#+end_src
* MyFunc
** my/beginning-of-intendation
#+begin_src emacs-lisp :tangle yes
  (defun my/beginning-of-intendation ()
    "move to beginning of line, or indentation"
    (interactive)
    (back-to-indentation))
#+END_SRC
** my/copy-buffer
#+begin_src emacs-lisp :tangle yes
  (defun my/copy-buffer ()
    (interactive)
    (save-excursion
      (mark-whole-buffer)
      (copy-region-as-kill (region-beginning) (region-end))))
#+end_src
** my/ghq-get
#+begin_src emacs-lisp :tangle yes
  (defun my/ghq-get ()
    (interactive)
    (let ((url (read-string "url > ")))
      (message
       (shell-command-to-string
        (mapconcat #'shell-quote-argument
                   (list "ghq" "get" url)
                   " ")))))
#+end_src
** my/gh-browse
#+begin_src emacs-lisp :tangle yes
  (defun my/gh-browse ()
    (interactive)
    (message
     (shell-command-to-string
      (mapconcat #'shell-quote-argument
                 (list "gh" "browse")
                 " "))))
#+end_src
** my/indent-all
#+begin_src emacs-lisp :tangle yes
  (defun my/indent-buffer ()
    (interactive)
    (save-excursion
      (mark-whole-buffer)
      (untabify (region-beginning) (region-end))
      (indent-region (region-beginning) (region-end))))
#+end_src
** my/move-line
#+begin_src emacs-lisp :tangle yes
  (defun my/move-line (arg)
    (interactive)
    (let ((col (current-column)))
      (unless (eq col 0)
        (move-to-column 0))
      (save-excursion
        (forward-line)
        (transpose-lines arg))
      (forward-line arg)))

  (defun my/move-line-down ()
    (interactive)
    (my/move-line 1))

  (defun my/move-line-up ()
    (interactive)
    (my/move-line -1))

  (keymap-global-set "M-N" #'my/move-line-down)
  (keymap-global-set "M-P" #'my/move-line-up)
#+end_src
** my/reload-major-mode
#+begin_src emacs-lisp :tangle yes
  (defun my/reload-major-mode ()
    "Reload current major mode."
    (interactive)
    (let ((current-mode major-mode))
      (fundamental-mode)
      (funcall current-mode)
      current-mode))
#+END_SRC
** my/toggle-kill-emacs
#+begin_src emacs-lisp :tangle yes
  (defvar my/kill-emacs-keybind-p t)

  (defun my/toggle-kill-emacs ()
    (interactive)
    (if my/kill-emacs-keybind-p
        (progn
          (message "C-x C-c save-buffers-kill-emacs OFF")
          (setq my/kill-emacs-keybind-p nil)
          (keymap-global-set "C-x C-c" nil))
      (progn
        (message "C-x C-c save-buffers-kill-emacs ON")
        (setq my/kill-emacs-keybind-p t)
        (keymap-global-set "C-x C-c" 'save-buffers-kill-emacs))))
#+end_src
** my/get-class-name-by-file-name
#+begin_src emacs-lisp :tangle yes
  (defun my/get-class-name-by-file-name ()
    (interactive)
    (insert
     (file-name-nondirectory
      (file-name-sans-extension (or (buffer-file-name)
                                    (buffer-name (current-buffer)))))))
#+end_src
** my/insert-clipboard
#+begin_src emacs-lisp :tangle yes
  (defun my/insert-clipboard (arg)
    (interactive "sstring: ")
    (kill-new arg))
#+end_src
** my/actionlint
#+begin_src emacs-lisp :tangle yes
  (defun my/actionlint ()
    (interactive)
    (shell-command-to-string "actionlint"))
#+end_src
** my/build-info
#+begin_src emacs-lisp :tangle yes
  (defun my/build-info ()
    "Display build information in a buffer."
    (interactive)
    (switch-to-buffer (get-buffer-create "*Build info*"))
    (setq tab-width 4)
    (let ((buffer-read-only nil))
      (erase-buffer)
      (insert (format "GNU Emacs %s\nCommit:\t\t%s\nBranch:\t\t%s\n"
                      emacs-version
                      emacs-repository-version
                      emacs-repository-branch))
      (insert (format "System:\t\t%s\nDate:\t\t%s\n"
                      system-configuration
                      (format-time-string "%Y-%m-%d %T (%Z)" emacs-build-time)))
      (insert (format "Patch:\t\t%s ns-inline.patch\n"
                      (if (boundp 'mac-ime--cursor-type) "with" "without")))
      (insert (format "Features:\t%s\n" system-configuration-features))
      (view-mode)))
#+end_src
** my/current-ip-address
#+begin_src emacs-lisp :tangle yes
  (defun my/current-ip-address ()
    (interactive)
    (insert
     (shell-command-to-string "curl -s ifconfig.me")))
#+end_src
** my/today
#+begin_src emacs-lisp :tangle yes
  (defun my/today (&optional iso-format)
    (interactive "P")
    (insert
     (format-time-string
      (if iso-format "%Y-%m-%dT%T%z" "%Y-%m-%d %a")
      (current-time))))
#+end_src
** my/subword
#+begin_src emacs-lisp :tangle yes
  (defun my/delete-forward-block ()
    (interactive)
    (if (eobp)
        (message "End of buffer")
      (let* ((syntax-move-point
              (save-excursion
                (skip-syntax-forward (string (char-syntax (char-after))))
                (point)))
             (subword-move-point
              (save-excursion
                (subword-forward)
                (point))))
        (kill-region (point) (min syntax-move-point subword-move-point)))))
#+end_src
** my/insert-date-at-point
#+begin_src emacs-lisp :tangle yes
  (defun my/insert-date-at-point ()
    "Minibufferで日付を選択し、カーソル位置に `YYYY/MM/DD DOW` フォーマットで挿入する。"
    (interactive)
    (let ((date (org-read-date nil nil nil "日付を選択してください:")))
      (insert (format-time-string "%Y/%m/%d %a" (org-time-string-to-time date)))))
#+end_src
* Footer
** Magic File Name を有効にする
#+begin_src emacs-lisp :tangle yes
  (setq file-name-handler-alist my/saved-file-name-handler-alist)
#+end_src
** profilerを終了する
#+begin_src emacs-lisp :tangle yes
  (when my/enable-profile
    (profiler-report)
    (profiler-stop))
#+end_src
